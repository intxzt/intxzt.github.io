{"meta":{"title":"MoYuno","subtitle":"","description":"这是一个兴趣盎然的无名小站","author":"许政通","url":"https://xuzhengtong.com","root":"/"},"pages":[{"title":"所有分类","date":"2024-08-13T16:30:13.162Z","updated":"2024-08-13T16:30:13.162Z","comments":true,"path":"categories/index.html","permalink":"https://xuzhengtong.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-08-13T16:30:13.162Z","updated":"2024-08-13T16:30:13.162Z","comments":true,"path":"tags/index.html","permalink":"https://xuzhengtong.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jellyfin硬解+tinymediamanager刮削","slug":"synology/jellyfin","date":"2023-04-16T12:16:37.000Z","updated":"2023-04-16T12:16:37.000Z","comments":true,"path":"2023/04/16/synology/jellyfin/","link":"","permalink":"https://xuzhengtong.com/2023/04/16/synology/jellyfin/","excerpt":"前言jellyfin, emby的免费版、折腾版。","text":"前言jellyfin, emby的免费版、折腾版。 安装 安装docker和docker-compose，群晖安装完docker自带docker-compose，之后在后台docker-compose up -d启动即可。 1234567891011121314version: &#x27;3&#x27;services: jellyfin: image: nyanmisaka/jellyfin user: 0:0 network_mode: &#x27;host&#x27; restart: unless-stopped volumes: - /volume1/docker/jellyfin/config:/config - /volume1/docker/jellyfin/cache:/cache - /volume2/media/medialnk:/media devices: - /dev/dri/card0:/dev/dri/card0 - /dev/dri/renderD128:/dev/dri/renderD128 硬解配置，之后播放视频查看cpu占用： 字幕： hlink硬连接如果你能接受媒体目录充斥着各种各样的nfo和jpg文件，此项不必须。官方文档 创建容器，注意源文件目录和硬连接目录作为docker映射必须在同一父目录下，nodejs应该没这限制，但是依然要在同一共享目录下。 给一个参考，注意如果有字幕文件也要把字幕文件后缀填入下方include。 不需要担心重命名之后再次运行hlink会再次生成硬连接，工具会判md5值，已经存在的文件不会重复生成： 目录结构： hlink配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 重要说明路径地址都请填写 绝对路径！！！！export default &#123;/*** 源路径与目标路径的映射关系 * 例子:* pathsMapping: &#123;* &#x27;/path/to/exampleSource&#x27;: &#x27;/path/to/exampleDest&#x27;,* &#x27;/path/to/exampleSource2&#x27;: &#x27;/path/to/exampleDest2&#x27;* &#125; */ pathsMapping: &#123; &#x27;/media/downloads&#x27;:&#x27;/media/medialnk&#x27; &#125;, /*** 需要包含的后缀，如果与exclude同时配置，则取两者的交集* include 留空表示包含所有文件** 后缀不够用? 高阶用法: https://hlink.likun.me/other/v2.html#%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD */ include: [ &#x27;mp4&#x27;, &#x27;flv&#x27;, &#x27;f4v&#x27;, &#x27;webm&#x27;, &#x27;m4v&#x27;, &#x27;mov&#x27;, &#x27;cpk&#x27;, &#x27;dirac&#x27;, &#x27;3gp&#x27;, &#x27;3g2&#x27;, &#x27;rm&#x27;, &#x27;rmvb&#x27;, &#x27;wmv&#x27;, &#x27;avi&#x27;, &#x27;asf&#x27;, &#x27;mpg&#x27;, &#x27;mpeg&#x27;, &#x27;mpe&#x27;, &#x27;vob&#x27;, &#x27;mkv&#x27;, &#x27;ram&#x27;, &#x27;qt&#x27;, &#x27;fli&#x27;, &#x27;flc&#x27;, &#x27;mod&#x27;, &#x27;iso&#x27;, ], /*** 需要排除的后缀，如果与include同时配置，则取两者的交集** 后缀不够用? 高阶用法: https://hlink.likun.me/other/v2.html#%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD */ exclude: [],/*** @scope 该配置项 hlink 专用* 是否保持原有目录结构，为false时则只保存一级目录结构* 可选值: true/false* 例子：* - 源地址目录为：/a* - 目标地址目录为: /d* - 链接的文件地址为 /a/b/c/z/y/mv.mkv；* 如果设置为true 生成的硬链地址为: /d/b/c/z/y/mv.mkv* 如果设置为false 生成的硬链地址为：/d/y/mv.mkv */ keepDirStruct: true, /*** @scope 该配置项 hlink 专用* 是否打开缓存，为true表示打开* 可选值: true/false* 打开后，每次硬链后会把对应文件存入缓存，就算下次删除硬链，也不会进行硬链 */ openCache: false, /*** @scope 该配置项 hlink 专用* 是否为独立文件创建同名文件夹，为true表示创建* 可选值: true/false */ mkdirIfSingle: true, /*** @scope 该配置项为 hlink prune 命令专用* 是否删除文件及所在目录，为false只会删除文件* 可选值: true/false */ deleteDir: false, &#125; 之后只需把medialnk目录给jellyfin和tinymediamanager即可，downloads用作原始媒体存放目录。 tinymediamanager刮削 受限于国内dns环境，TMDB的域经常会被dns污染，解决办法有修改容器host、代理（给jellyfin设置HTTTP_PROXY环境变量，记得过滤内网地址），即便如此，jellyfin自带的刮削依然会经常卡住，这里使用tinymediamanager刮削。 关于代理，由于我之前搞过一个电视盒子，装了armbian和软路由，内置了Clash，所以已经有现成的代理环境。需要代理环境的，需要使用docker装一个clash、软路由、或者同类软件。方法很多，教程也很多，不在赘述。 配置tinymediamanager代理（也可以修改host替代，可能会失效，要经常改） 刮削配置以电视剧为例，电影同理 媒体库： nfo： 抓取器： 检索，优先第二个，名字不规范等导致刮削不出来就第一个手动指定再刮。检索完成还有缺失的可以手动补一下： jellyfin配置： 媒体库勾选nfo和将媒体图像保存到媒体所在文件夹，其他全部取消勾选，效果：","categories":[{"name":"jellyfin","slug":"jellyfin","permalink":"https://xuzhengtong.com/categories/jellyfin/"}],"tags":[{"name":"jellyfin","slug":"jellyfin","permalink":"https://xuzhengtong.com/tags/jellyfin/"},{"name":"tinymediamanager","slug":"tinymediamanager","permalink":"https://xuzhengtong.com/tags/tinymediamanager/"}]},{"title":"黑群晖安装后基础配置（cpu核显、人脸识别补丁）","slug":"synology/init","date":"2023-04-16T10:18:18.000Z","updated":"2023-04-16T10:18:18.000Z","comments":true,"path":"2023/04/16/synology/init/","link":"","permalink":"https://xuzhengtong.com/2023/04/16/synology/init/","excerpt":"前言折腾黑裙也有一个多月了，记录下安装和使用的心得吧。","text":"前言折腾黑裙也有一个多月了，记录下安装和使用的心得吧。 关于安装折腾过All in one，pve的核显直通真的很难用；最后还是物理机安装来的简单，不折腾，功耗还比虚拟机低。 ps: 建议arpl安装，全程傻瓜操作不折腾。注意intel 8、9、10代CPU安装时菜单选择cpu驱动和cpuinfo（面板显示正确cpu信息），其他默认即可。 核显首先获取你的核显id: 官网查询地址： 命令&#96;lspci -v&#96;&#96;： 修改驱动文件 如果你在arpl安装的时候选择了集成核显驱动，那么在后台目录下你会找到i915的相关二进制文件，将你获取到的核显id对应文件重命名为i915.ko，之后重启即可： 验证cat /sys/kernel/debug/dri/0/i915_frequency_info： 人脸识别补丁参考地址：Synology_Photos_Face_Patch 默认能调用cpu识别的就不需要更改。其原理是关闭二进制文件中GPU支持，强制使用cpu，相册的CPU占用还好。核显给硬解用好了。","categories":[{"name":"Synology","slug":"Synology","permalink":"https://xuzhengtong.com/categories/Synology/"}],"tags":[{"name":"Synology","slug":"Synology","permalink":"https://xuzhengtong.com/tags/Synology/"},{"name":"人脸识别","slug":"人脸识别","permalink":"https://xuzhengtong.com/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"}]},{"title":"红米ax6s&魔百和m401a折腾日记","slug":"mini-hardware/mi-ax6s-route-m401a","date":"2023-01-02T12:05:46.000Z","updated":"2023-01-02T12:05:46.000Z","comments":true,"path":"2023/01/02/mini-hardware/mi-ax6s-route-m401a/","link":"","permalink":"https://xuzhengtong.com/2023/01/02/mini-hardware/mi-ax6s-route-m401a/","excerpt":"","text":"起因最近沉迷阿里云盘，使用potplayer配合aliyundrive-webdav可以轻松既存即播，but，如果想在手机、平板上使用，必须下载相应软件&amp;保持电脑开机，电脑的风扇声听起来确实不太美妙。想着搞个微型linux再配合jellyfin局域网播放岂不美哉。 然而想象很美好，现实很骨感，先说结论：路由器和电视盒子刷机很简单，但是受限于jellyfin对电视盒子amlogic芯片的解码能力的支持，jellyfin局域网播放折腾失败。 部分降级包、工具12链接：https://pan.baidu.com/s/1UGFowQodnWCj7yX5xsCEHg?pwd=pc39 提取码：pc39 ax6s路由刷机这个路由刷机不要怕，基本不会完全变砖。如果系统打不开，使用工具：MIWIFIRepairTool重刷1.2.7固件即可，工具每一步都会提示如何操作。 ps： 注意工具报毒，下载注意关闭杀毒软件 如果找不到对应路由器的ip，检查：路由器wan接网线、lan接电脑、禁用其他不相干网卡后重新打开工具 首次刷降级包1.2.7登入路由器管理后台，手动选择降级包刷入即可 之后telnet登入网关打开ssh用户名root，端口23，密码使用小米SN.html输入路由器背板sn计算得出（ssh密码也是这个），登录后依次执行： 12345nvram set ssh_en=1&amp; nvram set uart_en=1 &amp; nvram set boot_wait=on &amp; nvram setbootdelay=3 &amp; nvram set flag_try_sys1_failed=0 &amp; nvram setflag_try_sys2_failed=1nvram setflag_boot_rootfs=0 &amp; nvram set &quot;boot_fw1=run boot_rd_img;bootm&quot;nvram setflag_boot_success=1 &amp; nvram commit &amp; /etc/init.d/dropbear enable &amp;/etc/init.d/dropbear start 登录ssh后的操作这里需要两个文件：底包：factory.bin，sysupgradle.bin：可以在https://github.com/kiddin9/OpenWrt_x86-r2s-r4s-r5s-N1定制所需软件后下载，如果使用他的网站定制镜像提示每天只能跑一次，清除cookie后再试。下边是我预编译的软件： 注意如果装docker，估计磁盘还剩下20m左右，稍微大一点的镜像都拉不下来，索性不装。 首先刷入底包上传factory.bin至/tmp目录，其他目录可能空间不够导致上传失败，之后执行： 1mtd -r write /tmp/factory.bin firmware 注意底包只需要刷入一次 之后刷入正式包点击刷写固件，按提示操作（勾选全部去掉） 装完长这样 最后ClashX YYDS魔百和m401a刷armbian电视盒子便宜，拼夕夕花了67，后来咸鱼看了下，大概60左右可以拿下，大致配置如下： 准备工具： u盘 usb-typec数据线（电脑需要有typec接口，注意某些充电线可能无法使用，我用的是之前旧手机的原装数据线）或者 usb双公数据线 键盘、鼠标、显示屏、网线必须 螺丝刀，线刷拆机 遥控器非必须，可用键鼠操作 短接的镊子&#x2F;挖耳勺等等 降级变砖状态也使用此步骤修复。 拆机接ttl盒子背面正放，拆下右上和左下两颗螺丝即可打开背板，尝试如下三个位置复位&#x2F;短接，建议先尝试复位键。先按下复位&#x2F;短接，之后连数据线到电脑（无需插电源），听到提示音即连接成功 刷降级包连接成功后使用usb-burning-tool刷入江苏M401A原机官改root线刷超级桌面镜像，此镜像自带root、打开adb调试。 准备u盘 下载镜像：amlogic-s9xxx-armbian，下载s905l3a标号，建议选5.x的内核 jammy：Ubuntu最新发行版代号 bullseye：Debian最新发行版代号 下载工具： balenaEtcher 插入u盘打开工具，Flash from file 将镜像写入u盘 打开u盘：修改文件uEnv.txt对应的dtb 1FDT=/dtb/amlogic/meson-g12a-s905l3a-m401a.dtb 刷机 盒子接显示屏、电源、鼠标&#x2F;遥控、网线（装机时可能涉及一些网络配置），键盘暂时不接，如果用遥控可以接键盘，因为要留一个口接u盘，注意这时不插u盘，这个很重要，假如你在android系统下插u盘，它会修改u盘文件权限，导致无法引导。 进入系统，鼠标&#x2F;遥控打开应用libreelec.apk，黑屏之后插入u盘、键盘，如果进入android的机器人界面说明操作失败，需要检查u盘重试。 看到花屏，先开心一下，说明\bu盘引导成功了，之后按界面提示设置root密码即可，默认密码1234 ps：create account步骤可以ctrl+c跳过 进入系统后，不要着急刷入emmc，先检查下cpu、内存、磁盘、网络等是否正常。不正常检查相关配置或者进入github issue求助。 armbian-install刷入emmc，id选306（对应401a）、磁盘格式选ext 之后shutdown now，拔出u盘再开机 长这样 可选（固定ip、虚拟域名）固定ip 虚拟域名 之后可通过此虚拟域名局域网访问该系统资源：","categories":[{"name":"hardware","slug":"hardware","permalink":"https://xuzhengtong.com/categories/hardware/"}],"tags":[{"name":"readmi ax6s","slug":"readmi-ax6s","permalink":"https://xuzhengtong.com/tags/readmi-ax6s/"},{"name":"m401a","slug":"m401a","permalink":"https://xuzhengtong.com/tags/m401a/"},{"name":"openwrt","slug":"openwrt","permalink":"https://xuzhengtong.com/tags/openwrt/"},{"name":"armbian","slug":"armbian","permalink":"https://xuzhengtong.com/tags/armbian/"}]},{"title":"ja-netfilter power插件原理","slug":"ja-netfilter/ja-netfilter-plugins-power","date":"2022-07-25T14:51:02.000Z","updated":"2022-07-25T14:51:02.000Z","comments":true,"path":"2022/07/25/ja-netfilter/ja-netfilter-plugins-power/","link":"","permalink":"https://xuzhengtong.com/2022/07/25/ja-netfilter/ja-netfilter-plugins-power/","excerpt":"关键点 源码仓：https://gitee.com/ja-netfilter/ja-netfilter, 码云还能用, 作者的github已被封禁","text":"关键点 源码仓：https://gitee.com/ja-netfilter/ja-netfilter, 码云还能用, 作者的github已被封禁 pow插件的代码很少，基本原理是通过java agnet代理来替换RSA中模幂运算的结果来伪造验签，并配合其他插件去掉联网激活。 当前分析是基于https://jetbra.in网站大佬的power配置，结合RSA以及证书的相关知识反推出激活过程，完全逆向分析出验证过程我并不会。 power插件配置如下, 只看第一个配置即可，理论上只有第一个配置即可完成激活： EQUAL,x,y,z-&gt;fakeResult 对于这里的情况，就是x.modpow(y,z)=fakeResult, 就是匹配x,y,z三个参数, 并替换模幂运算结果为fakeResult, x:证书的签名密文；y:指数；z：jetbrains内置root证书的公钥的模；fakeResult：证书签名（sh256摘要后的明文）ASN.1格式再进行填充。 jetbrains的验证主要就是证书的验签，主要就是5里的内容，但是还有一点需要特别注意，4096位证书的签名域大概会有2000多位，但是2048位证书要短的多，jetbrains内置应该会对这个长度校验，因为2048位证书生成的密钥激活不成功 基本流程 下面是生成一个可用证书的代码。相关证书配置可参考cryptography文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import datetimefrom cryptography import x509from cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import hashes, serializationfrom cryptography.hazmat.primitives.asymmetric import rsafrom cryptography.x509.oid import NameOIDone_day = datetime.timedelta(days=1)ten_day = datetime.timedelta(days=3650)today = datetime.datetime.today()yesterday = today - one_daytomorrow = today + ten_dayprivate_key = rsa.generate_private_key( public_exponent=65537, key_size=4096, backend=default_backend())public_key = private_key.public_key()builder = x509.CertificateBuilder()builder = builder.subject_name(x509.Name([ x509.NameAttribute(NameOID.COMMON_NAME, &#x27;MoYuno-from-2022-07-25&#x27;),]))builder = builder.issuer_name(x509.Name([ x509.NameAttribute(NameOID.COMMON_NAME, &#x27;JetProfile CA&#x27;),]))builder = builder.not_valid_before(yesterday)builder = builder.not_valid_after(tomorrow)builder = builder.serial_number(x509.random_serial_number())builder = builder.public_key(public_key)certificate = builder.sign( private_key=private_key, algorithm=hashes.SHA256(), backend=default_backend())private_bytes = private_key.private_bytes( encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.TraditionalOpenSSL, encryption_algorithm=serialization.NoEncryption())public_bytes = certificate.public_bytes( encoding=serialization.Encoding.PEM)with open(&quot;ca.key&quot;, &quot;wb&quot;) as fout: fout.write(private_bytes)with open(&quot;ca.crt&quot;, &quot;wb&quot;) as fout: fout.write(public_bytes) 下面为生成key代码，将第一、第二行输出替换到power配置，第三行即为激活key, ca.key为保存证书私钥的文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import base64from Crypto.Hash import SHA1, SHA256from Crypto.PublicKey import RSAfrom Crypto.Signature import pkcs1_15from Crypto.Util.asn1 import DerSequence, DerObjectId, DerNull, DerOctetStringfrom Crypto.Util.number import ceil_divfrom cryptography import x509from cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.asymmetric import padding# noinspection PyTypeCheckerdef pkcs15_encode(msg_hash, emLen, with_hash_parameters=True): &quot;&quot;&quot; Implement the ``EMSA-PKCS1-V1_5-ENCODE`` function, as defined :param msg_hash: hash object :param emLen: int :param with_hash_parameters: bool :return: An ``emLen`` byte long string that encodes the hash. &quot;&quot;&quot; digestAlgo = DerSequence([DerObjectId(msg_hash.oid).encode()]) if with_hash_parameters: digestAlgo.append(DerNull().encode()) digest = DerOctetString(msg_hash.digest()) digestInfo = DerSequence([ digestAlgo.encode(), digest.encode() ]).encode() # We need at least 11 bytes for the remaining data: 3 fixed bytes and # at least 8 bytes of padding). if emLen &lt; len(digestInfo) + 11: raise TypeError(&quot;Selected hash algorithm has a too long digest (%d bytes).&quot; % len(digest)) PS = b&#x27;\\xFF&#x27; * (emLen - len(digestInfo) - 3) return b&#x27;\\x00\\x01&#x27; + PS + b&#x27;\\x00&#x27; + digestInfocertBase64 = &quot;MIIFTDCCAzSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMDcyNTIzMTcwOVoXDTMyMDcyMzIzMTcwOVowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDDx3gz77KvezmZJhwkF/10Q3vESk96tK6wJ00CSKkLybRDeQVOlHX3QAnPL7BjwCTzHqErsuyPuiZ6YTAVE/n7hLhIbh3lC+EBbxpa2hpIdIvUimr70iSrH9ZBWmnn5Fxy4r/r0tbxr34zpQzu4uWLiEqmOiDfRN+Zzj9FBaJ/gKsuhF7zNAbFHsClYntim5furDRITBra28nu0hfQIEBSHGPS2EKWTbKk2ifBLzMEDp99zIGEe/hrLpgBhdwGVD7VJsoeTXnvcgpt+91kiM918GWThO1L3eKU6W2mGZQv1bRyps7Fo61NElNWtJqqZ3KKyxJGyR1QpdOHd9flAesvYwb/lvc4uqYiKqwvvn+4iHPQlLtZDbzj0ICbKtVKSWgSprh0T5ZQGGNWXN4OMHtg9EuXvbagLshTEDkLKLzEBqSNpNmMmyzwyNO9/voQmHLjiWLdjVIYndjl15G+A9Dw5mVYqzKPMLEpHzg6ldkKJkGAxNBhCMUsmbEypT6r7wsdTvgEwFnP8ToOsAb12lSLxoR2bOT3xJ3WIfbyjvlBnauXfdu6SFF/82QFrLtQyddPvCHEiJTI0NmSYhjQObFohXMVVoXjGbXvuqgJNbc5UK06pCGQ2jKw4j6k1kw2g4fEYBd1fvEzb1/t+izpP8dEI0365xh0C1dpQjUj3uyRywIDAQABo4GZMIGWMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwCQYDVR0TBAIwADATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwHQYDVR0OBBYEFCTaESKW9YVBwJNH6DEjTPTAhAL/MA0GCSqGSIb3DQEBCwUAA4ICAQA29wUDKatiQe1S0qfId+1dRWnYznrHE0Cx41HUaeI5hvdZrFbDIP6syb/S9oAXST6w4pfgh80jk1xVL+B7NT5kFC+AI7mpd8dK8Z+K67tagYg41TdLGfSHqK+lljln5ElqUEN21fba5CVZplE286jy973XFOFbWZUpJC/5onCCAh8pK8AqpN7k3ovR6bfAga41UWdTnGeiyw9+XOj30ryebseTKaDfjQxsxEmyuA8YYCu9lgb58cvVrvc99So8KdOBaxHnxeEfiUqvPA8Y0QG7lc5elZYQ6cbiIqqsb/k9XSgB2Gk4CjuacBSxCAfd06NlJvZSDFSR1HTKhQfPLIQY1OpBC+NrKRWnQT4/IORL6F36gI9lTK+ioX8mzQ2bvXn4sXA3jrpRnGM2WemQvMPvstfSDKfcUdKjwX3rZ2jMwREkx/thtF3Huvsc8suOyzto1faD8mV0m4guq85fb4c9ki6cinz3QM2k6otVvh67gK116RZ7I8P/urTWvK7IOdwOE7UVqtpEe6TKvNhr1rzeaxUMdPcD0kY7fhBpuPwEQA+Xk0uiVR+XbpaPD4HWuapJm+31jC7zBp/BamRI25v26P5qMUQF/+P7eE4Ah/X0Rtf2Qvr2+p9kbfqalT8EiqOsvRiTvlMG1hdo33JdcwsxC05BWvZ++7Af0FgJ3TtFlw==&quot;cert = x509.load_der_x509_certificate(base64.b64decode(certBase64))public_key = cert.public_key()sign = int.from_bytes(cert.signature, byteorder=&quot;big&quot;, )print(f&quot;sign:&#123;sign&#125;&quot;)modBits = public_key.key_sizedigest_cert = SHA256.new(cert.tbs_certificate_bytes)r = int.from_bytes(pkcs15_encode(digest_cert, ceil_div(modBits, 8)), byteorder=&#x27;big&#x27;, signed=False)print(f&quot;result:&#123;r&#125;&quot;)licenseId = &#x27;ZCB571FZHV&#x27;licensePart = &#x27;&#123;&quot;licenseId&quot;: &quot;ZCB571FZHV&quot;, &quot;licenseeName&quot;: &quot;MoYuno&quot;, &quot;assigneeName&quot;: &quot;&quot;, &quot;assigneeEmail&quot;: &quot;&quot;, &quot;licenseRestriction&quot;: &quot;&quot;, &quot;checkConcurrentUse&quot;: false, &quot;products&quot;: [&#123;&quot;code&quot;: &quot;PDB&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: true&#125;, &#123;&quot;code&quot;: &quot;PSI&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: true&#125;, &#123;&quot;code&quot;: &quot;PPC&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: true&#125;, &#123;&quot;code&quot;: &quot;PCWMP&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: true&#125;, &#123;&quot;code&quot;: &quot;PPS&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: true&#125;, &#123;&quot;code&quot;: &quot;PRB&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: true&#125;, &#123;&quot;code&quot;: &quot;II&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: false&#125;, &#123;&quot;code&quot;: &quot;PGO&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: true&#125;, &#123;&quot;code&quot;: &quot;PSW&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: true&#125;, &#123;&quot;code&quot;: &quot;PWS&quot;, &quot;fallbackDate&quot;: &quot;2030-12-31&quot;, &quot;paidUpTo&quot;: &quot;2030-12-31&quot;, &quot;extended&quot;: true&#125;], &quot;metadata&quot;: &quot;0120220701PSAN000005&quot;, &quot;hash&quot;: &quot;TRIAL:-594988122&quot;, &quot;gracePeriodDays&quot;: 7, &quot;autoProlongated&quot;: false, &quot;isAutoProlongated&quot;: false&#125;&#x27;digest = SHA1.new(licensePart.encode(&#x27;utf-8&#x27;))with open(&#x27;ca.key&#x27;) as prifile: private_key = RSA.import_key(prifile.read()) # 使用私钥对HASH值进行签名 signature = pkcs1_15.new(private_key).sign(digest) sig_results = base64.b64encode(signature) licensePartBase64 = base64.b64encode(bytes(licensePart.encode(&#x27;utf-8&#x27;))) public_key.verify( base64.b64decode(sig_results), base64.b64decode(licensePartBase64), padding=padding.PKCS1v15(), algorithm=hashes.SHA1(), ) result = licenseId + &quot;-&quot; + licensePartBase64.decode(&#x27;utf-8&#x27;) + &quot;-&quot; + sig_results.decode(&#x27;utf-8&#x27;) + &quot;-&quot; + certBase64 print(result) power配置 123[Result]EQUAL,299213640480477532232613356963433702031002251045851034447586414483519966756292278486543340805051010387298654019573363272008360784689022119017890774114551027339708503004045350343586644811618864305881845465533648400689567858742575422559970141004668011335270078334407666830207988469779150466837407714233763706094062000639780603973844773087781508392275584101394349697501544157473450756019949199684259212935405319499144363514324449339190870632316321795482940183529552098938554099062136011084894473851845239116184148986281123972659644878799379380261449920696338120543502812544746767898798943314889294194101292036595639371186775347484567397344395184405355790360065442444860205472364733334389986946974705941726087707844500957983916062459453221933893215161372392731381189453820187891087273544552705596167883641667321388071603600011784878991949691982964403655253904545535007628440853843739961414609377533977442694446499647779793529580697861112506950060413115797629255454796936312507751116190662225936971532934134905675293377129487625260335951037389915705838362760349227579537971722730753029711967720727791938130994188333268180862035329802322328559778203266156173042101769378930210077375824223343237114381772298569863055041850568390194480790793,65537,860106576952879101192782278876319243486072481962999610484027161162448933268423045647258145695082284265933019120714643752088997312766689988016808929265129401027490891810902278465065056686129972085119605237470899952751915070244375173428976413406363879128531449407795115913715863867259163957682164040613505040314747660800424242248055421184038777878268502955477482203711835548014501087778959157112423823275878824729132393281517778742463067583320091009916141454657614089600126948087954465055321987012989937065785013284988096504657892738536613208311013047138019418152103262155848541574327484510025594166239784429845180875774012229784878903603491426732347994359380330103328705981064044872334790365894924494923595382470094461546336020961505275530597716457288511366082299255537762891238136381924520749228412559219346777184174219999640906007205260040707839706131662149325151230558316068068139406816080119906833578907759960298749494098180107991752250725928647349597506532778539709852254478061194098069801549845163358315116260915270480057699929968468068015735162890213859113563672040630687357054902747438421559817252127187138838514773245413540030800888215961904267348727206110582505606182944023582459006406137831940959195566364811905585377246353-&gt;31872219281407242025505148642475109331663948030010491344733687844358944945421064967310388547820970408352359213697487269225694990179009814674781374751323403257628081559561462351695605167675284372388551941279783515209238245831229026662363729380633136520288327292047232179909791526492877475417113579821717193807584807644097527647305469671333646868883650312280989663788656507661713409911267085806708237966730821529702498972114194166091819277582149433578383639532136271637219758962252614390071122773223025154710411681628917523557526099053858210363406122853294409830276270946292893988830514538950951686480580886602618927728470029090747400687617046511462665469446846624685614084264191213318074804549715573780408305977947238915527798680393538207482620648181504876534152430149355791756374642327623133843473947861771150672096834149014464956451480803326284417202116346454345929350148770746553056995922154382822307758515805142704373984019252210715650875853634697920708113806880196144197384637328982263167395073688501517286678083973976140696077590122053014085412828620051470085033364773099146103525313018873319293728800442101520384088109603555959893639842091339193875424402372756980690316933413386064082742205939246341134023323525564261538670 key 12VAE9B0CRYZ-eyJsaWNlbnNlSWQiOiAiVkFFOUIwQ1JZWiIsICJsaWNlbnNlZU5hbWUiOiAiTW9ZdW5vIiwgImFzc2lnbmVlTmFtZSI6ICIiLCAiYXNzaWduZWVFbWFpbCI6ICIiLCAibGljZW5zZVJlc3RyaWN0aW9uIjogIiIsICJjaGVja0NvbmN1cnJlbnRVc2UiOiBmYWxzZSwgInByb2R1Y3RzIjogW3siY29kZSI6ICJQU0kiLCAiZmFsbGJhY2tEYXRlIjogIjIwMzAtMTItMzEiLCAicGFpZFVwVG8iOiAiMjAzMC0xMi0zMSIsICJleHRlbmRlZCI6IHRydWV9LCB7ImNvZGUiOiAiUEMiLCAiZmFsbGJhY2tEYXRlIjogIjIwMzAtMTItMzEiLCAicGFpZFVwVG8iOiAiMjAzMC0xMi0zMSIsICJleHRlbmRlZCI6IGZhbHNlfSwgeyJjb2RlIjogIlBQQyIsICJmYWxsYmFja0RhdGUiOiAiMjAzMC0xMi0zMSIsICJwYWlkVXBUbyI6ICIyMDMwLTEyLTMxIiwgImV4dGVuZGVkIjogdHJ1ZX0sIHsiY29kZSI6ICJQQ1dNUCIsICJmYWxsYmFja0RhdGUiOiAiMjAzMC0xMi0zMSIsICJwYWlkVXBUbyI6ICIyMDMwLTEyLTMxIiwgImV4dGVuZGVkIjogdHJ1ZX0sIHsiY29kZSI6ICJQV1MiLCAiZmFsbGJhY2tEYXRlIjogIjIwMzAtMTItMzEiLCAicGFpZFVwVG8iOiAiMjAzMC0xMi0zMSIsICJleHRlbmRlZCI6IHRydWV9XSwgIm1ldGFkYXRhIjogIjAxMjAyMjA3MDFQU0FOMDAwMDA1IiwgImhhc2giOiAiVFJJQUw6MTMxNzYyODYxMCIsICJncmFjZVBlcmlvZERheXMiOiA3LCAiYXV0b1Byb2xvbmdhdGVkIjogZmFsc2UsICJpc0F1dG9Qcm9sb25nYXRlZCI6IGZhbHNlfQ==-MkDyzvbXWknbzvzkgq9VbTnXNnLqF+j7MLYVYsMc75aGcTMKmEsSN2mSvgbyC4NHbJI4jxwo8+5c2KOP6OrBAxDrFnJCgc/OSOf4T56nMARLpisMly90p68/6sU7b2f0xCuIY6Gs97pDtPIc12lRnrVQv2Sycz3W0pYMBxQkIGNtsXMDdPShPDT7TD1zicTDV6lhwuDIhP6LYLUVWSfDN6DczQRDmUGm1KzNSlFBdoYGUXYCkYKffo7hukCW6ZKdfJLywLwJnabpd6tQDb6kc5gpEhNh6+GzVZXKYvA5PyRlt8RjBT7w0Jim96JH48VyD/+GGa0e8V2Nw6U/uG73LdmPEg2hGF7eKvC+0zU4rpQvj0hUJcvm1r+VQPWDJc+EA+Is3i95Xl56yyAa3JHQ7zOjegQLeYv/+uuPgKqHHpf7X7i+rvRtAQMC1KFNl8wLQJFLp/JGSQ4kVBUpxMuV0o/LDUKn3qs/DwIl7gq24igtEM+wluv0AwKvOUQkGFMgaCqA61GgbJqUaBXleo/GAII72+7GHlAoLv4XJdISfY9x6+iuH96lfTEr2qgdGIKxIz3pT7jhgh1qm+BdSGyB3pJo4cKV530XvuoAZl5scCgz6xQMS+mW+V8bx6nmVKTn0V0qOdaeggIjotjL9mtWlVEguIAPpKJxbBMhZRbrMo0=-MIIExTCCAq2gAwIBAgIUZKjG0XIFJFl/6PfqfOCE4LyPxVowDQYJKoZIhvcNAQELBQAwGDEWMBQGA1UEAwwNSmV0UHJvZmlsZSBDQTAeFw0yMjA3MjgwMTQzNThaFw0zMjA3MjYwMTQzNThaMCExHzAdBgNVBAMMFk1vWXVuby1mcm9tLTIwMjItMDctMjUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDhykmyOmP3Geexl39gcTG+wuvLUyZxjhuFLutWBud3b10U1yRiz87NUk/NCAId3Qr8qiqwW3Kqe1FpDWG4HUWbIdNYtaRalMAkCSaLXe6QCymtJOpTgbSYwrql8nJJxZ8OLBbyFMdURsWAJFT4DDIZ9J62xSKeTBbSNwfm5vIeKkoHrqHTlQWP1pXkgEE5D91EQ1UcOzkCdNyW9rphQpk9ZfD/0+QBxS06zgngh53UeJSAFGKWyPlQrhwfOp+8AEcwkwFI20T5UzsQFZ5jjgpfg2GlNiMuvM48bXFybMB0yFes54ukKPnmgOb8BQ7fKuSgB2ZTOGQT1YcAI8/zJECcXYaLOnaQ7UA8WKyXY9bPHxXykW/xHIrHK11hnmgMY0rnVKVeVke+DsiVT/E7KvjburWiDCm5yAeoG7hZXIoCm3+rwzG2w6lzVIM1/J1XN4e8BWS6ZUKuMaPwX5nOmWFLl7FgTPEC9JQasSFhSdeWHiHT3+jJD3SDxG2fVJkGE8WvFFFI90NPmYELnAU7byEqiuJYapkawIlNARWYgGTi8JMxN8jB2yGofBb/s+cG/JEWmTWMoPrwmfVxKfC5M72iob8hZf9NCmJ33iKCotIyIT5NkUKeGw1CrQx+CH/MJqb0CCtwVnSm8crNc/Lf/ufnBOH+IeD4wM2YlW+8g1XTHQIDAQABMA0GCSqGSIb3DQEBCwUAA4ICAQBJV9PB17o4P6+4v2gC6RBSeAIbePx4YyVXo/uRbALf/MBs70kg+LXcQPGS8KTWHKntKUHyZezprMBG2X8NO1EUtKNhA4enFA6zZP+9qCzxfHsdZKG/nVgrvD34xmPovhWpTaQgQwtfruXESWEtVMyk0qQxaMf5VtpFw/3CUXljCpmGi1nNuQerF+Bhp63lpUv3qpyG9Hz0iRpO77xC0VhnCCQ3yB1DoIJZ6g97+6cxdsFTFCqsEGVrclolkkiFRURFqBkF4K9v/N39rc4JL42uvGMMD/gZBFVYhPuIsAgIwrp42q+SmDbr0VnVZFozpEE7ljQv8W4C6BxcDKbQX1ejrmxsXtYu+1M/ot7ljT4XXAeuqUkYb+6ly+kwTbuc0hqFsVLB4Vr+y3rZbK1IVTFH+QCrl7Kj8feT5WgsWYelMK1N/n/X5sK1Y7d8ZrdcbUJIet11zoDaHDKyvUDow5h4WQmfkZSD1FYk3ddBdRmEWl8D7vZ/SKuwHS5yhR7OIOiFHl4WoTQsihaNPadFDJ9PdUKAu9YE8CFrSoE+CO6QsQihl0iD889woqLnMwJIB5Mi7oSy43yIWK4oB5RI/uObqqOEiD/J3bmM/dOKxcf6Z9M8lTBPR+3L6QKPpSag3hBAsoofY8S2unKa/e+5mfjOp1ox8JcjlgKWt/V9NH+9CQ== 2022.2由于默认启用jdk17，需额外添加 12--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 结果","categories":[{"name":"ja-netfilter","slug":"ja-netfilter","permalink":"https://xuzhengtong.com/categories/ja-netfilter/"}],"tags":[{"name":"ja-netfilter","slug":"ja-netfilter","permalink":"https://xuzhengtong.com/tags/ja-netfilter/"}]},{"title":"RSA加密&签名","slug":"secure/RSA","date":"2022-07-25T13:58:11.000Z","updated":"2022-07-25T13:58:11.000Z","comments":true,"path":"2022/07/25/secure/RSA/","link":"","permalink":"https://xuzhengtong.com/2022/07/25/secure/RSA/","excerpt":"加密&amp;解密 任选两个不同质数p和q,计算乘积 N = p*q, r = (p - 1)*(q - 1)","text":"加密&amp;解密 任选两个不同质数p和q,计算乘积 N = p*q, r = (p - 1)*(q - 1) 任选一个模数e，满足(r,e) = 1 确定公钥:$$&lt;N, e&gt;$$ 确定私钥d:(d满足)$$&lt;N, d&gt;:: de &#x3D; xr+1，x为常数$$ 销毁除公钥和私钥外所有数据，公开公钥，仔细保存私钥 加密步骤：明文m(必须 &lt; N),密文c $$m^e mod N &#x3D; c$$ 解密步骤： $$c^d mod N &#x3D; m$$ 签名&amp;验签签名 计算Hash $$h &#x3D; hash(msg)$$ 对h进行加密得到签名结果s $$s &#x3D; h^d mod N$$ 验证签名 计算Hash $$h &#x3D; hash(msg)$$ 对密文解密得到h1 $$h1 &#x3D; s^e mod N$$ h = h1则签名验证成功 示例 任选两个质数11,17,计算成绩N &#x3D; 187,r &#x3D; 160 选取一个模数e &#x3D; 3 公钥： (187, 3) 私钥： (187, 107) 加密 m &#x3D; 49 计算密文$$c &#x3D; 49^3 mod 187 &#x3D; 26$$ 解密 计算明文$$m &#x3D; 26^{107} mod 187 &#x3D; 49$$ 签名 假设hash(msg) &#x3D; 5$$s &#x3D; 5^{107} mod 187 &#x3D; 113$$ 验签 $$h1 &#x3D; 113^3 mod 187 &#x3D; 5$$ 安全性分析一般的破解方法是将N因式分解为互不相同质数，然后按以上步骤暴力枚举。所以破解难度与极大值因数分解难度等价。","categories":[{"name":"加密算法","slug":"加密算法","permalink":"https://xuzhengtong.com/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"name":"RSA","slug":"加密算法/RSA","permalink":"https://xuzhengtong.com/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/RSA/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://xuzhengtong.com/tags/RSA/"}]},{"title":"字典树（前缀树Trie）","slug":"algorithms/trie","date":"2021-05-23T16:05:37.000Z","updated":"2021-05-23T16:05:37.000Z","comments":true,"path":"2021/05/24/algorithms/trie/","link":"","permalink":"https://xuzhengtong.com/2021/05/24/algorithms/trie/","excerpt":"基本结构字典树，即Trie树，又称单词查找树或者键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。","text":"基本结构字典树，即Trie树，又称单词查找树或者键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 它的优点是：最大限度的减少无谓的字符串比较，查询效率比哈希表高。 基本性质 节点本身不存完整单词 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点路径代表的字符都不相同。 核心思想Trie树的核心思想是空间换时间。 利用字符串的公告前缀来降低查询时间的开销以达到提高效率的目的。 实现Trie树——leetcode 208123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.xzt.solutions;public class Solution208 &#123; class Trie &#123; private TrieNode root; /** * Initialize your data structure here. */ public Trie() &#123; root = new TrieNode(); &#125; /** * Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char cur = word.charAt(i); if (!node.containsKey(cur)) &#123; node.put(cur, new TrieNode()); &#125; node = node.get(cur); &#125; node.setEnd(); &#125; /** * Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); &#125; /** * Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; return searchPrefix(prefix) != null; &#125; private TrieNode searchPrefix(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char cur = word.charAt(i); if (!node.containsKey(cur)) &#123; return null; &#125; node = node.get(cur); &#125; return node; &#125; &#125; class TrieNode &#123; private TrieNode[] links; public final int R = 26; private boolean isEnd; public TrieNode() &#123; links = new TrieNode[R]; &#125; public boolean containsKey(char ch) &#123; return links[ch - &#x27;a&#x27;] != null; &#125; public TrieNode get(char ch) &#123; return links[ch - &#x27;a&#x27;]; &#125; public void put(char ch, TrieNode node) &#123; links[ch - &#x27;a&#x27;] = node; &#125; public void setEnd() &#123; isEnd = true; &#125; public boolean isEnd() &#123; return isEnd; &#125; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Trie","slug":"数据结构与算法/Trie","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Trie/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://xuzhengtong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"1473. 粉刷房子 III","slug":"leetcode/leetcode1473","date":"2021-05-05T14:28:36.000Z","updated":"2021-05-05T14:28:36.000Z","comments":true,"path":"2021/05/05/leetcode/leetcode1473/","link":"","permalink":"https://xuzhengtong.com/2021/05/05/leetcode/leetcode1473/","excerpt":"粉刷房子 III在一个小城市里，有&nbsp;m&nbsp;个房子排成一排，你需要给每个房子涂上 n&nbsp;种颜色之一（颜色编号为 1 到 n&nbsp;）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。","text":"粉刷房子 III在一个小城市里，有&nbsp;m&nbsp;个房子排成一排，你需要给每个房子涂上 n&nbsp;种颜色之一（颜色编号为 1 到 n&nbsp;）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。 我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区&nbsp; [&#123;1&#125;, &#123;2,2&#125;, &#123;3,3&#125;, &#123;2&#125;, &#123;1,1&#125;] 。） 给你一个数组&nbsp;houses&nbsp;，一个&nbsp;m * n&nbsp;的矩阵&nbsp;cost&nbsp;和一个整数&nbsp;target&nbsp;，其中： houses[i]：是第&nbsp;i&nbsp;个房子的颜色，0&nbsp;表示这个房子还没有被涂色。 cost[i][j]：是将第&nbsp;i&nbsp;个房子涂成颜色&nbsp;j+1&nbsp;的花费。 请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成&nbsp;target&nbsp;个街区。如果没有可用的涂色方案，请返回&nbsp;-1&nbsp;。 &nbsp; 示例 1： 输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出：9 解释：房子涂色方案为 [1,2,2,1,1] 此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。 涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。 示例 2： 输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出：11 解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2] 此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。 给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。 示例 3： 输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5 输出：5 示例 4： 输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3 输出：-1 解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。 &nbsp; 提示： m == houses.length == cost.length n == cost[i].length 1 &lt;= m &lt;= 100 1 &lt;= n &lt;= 20 1 &lt;= target&nbsp;&lt;= m 0 &lt;= houses[i]&nbsp;&lt;= n 1 &lt;= cost[i][j] &lt;= 10^4 Related Topics 动态规划 分析 将房区初始颜色编码从0开始计算，-1表示未涂颜色。 记dp[i][j][k]为第i个房子涂成颜色j的花费，它属于第k个街区 我们讨论第i个房子花费：若i!=0，设第i-1个房子颜色为j0 对于houses[i] = -1，即房子未涂颜色。分为两种情况： j = j0：颜色和i-1一致，i和i-1属于同一街区，得如下转移方程：$$dp[i][j][k] &#x3D; dp[i-1][j][k] + const[i][j]$$ j != j0：颜色变化，i和i-1不属于同一街区，得如下转移方程：$$dp[i][j][k] &#x3D; dp[i-1][j0][k-1] + const[i][j]$$ 对于houses[i] != -1，即房子有初始颜色j，这种情况必须将房子涂成颜色j。同样分为两种情况： j = j0：颜色和i-1一致，i和i-1属于同一街区，这时不需要额外为i涂色。得如下转移方程：$$dp[i][j][k] &#x3D; dp[i-1][j][k]$$ j != j0：颜色变化，i和i-1不属于同一街区，这时不需要额外为i涂色，得如下转移方程：$$dp[i][j][k] &#x3D; dp[i-1][j0][k-1]$$ 若i = 0，由于第一个房子，所以k = 0，花费不由上一个房子转移得到。，分为两种情况： houses[i] = -1，即房子未涂颜色，花费：const[i][j] houses[i] != -1，即房子有初始颜色j，j = j0，花费：0 转化为代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Solution1473 &#123; private static final int INFTY = Integer.MAX_VALUE / 2; public int minCost(int[] houses, int[][] cost, int m, int n, int target) &#123; for (int i = 0; i &lt; houses.length; i++) &#123; houses[i]--; &#125; int[][][] dp = new int[m][n][target]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; Arrays.fill(dp[i][j], INFTY); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (houses[i] != -1 &amp;&amp; houses[i] != j) &#123; continue; &#125; for (int k = 0; k &lt; target; k++) &#123; for (int j0 = 0; j0 &lt; n; j0++) &#123; if (j == j0) &#123; if (i == 0) &#123; if (k == 0) &#123; // 第一个房子初始为0 dp[i][j][k] = 0; &#125; &#125; else &#123; dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k]); &#125; &#125; else if (i &gt; 0 &amp;&amp; k &gt; 0) &#123; // 非第一个房子 dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j0][k - 1]); &#125; &#125; if (houses[i] == -1) &#123; // 第一个房子或者变更房区--未涂颜色 dp[i][j][k] += cost[i][j]; &#125; &#125; &#125; &#125; int ans = INFTY; for (int i = 0; i &lt; n; i++) &#123; ans = Math.min(ans, dp[m - 1][i][target - 1]); &#125; return ans == INFTY ? -1 : ans; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"数据结构与算法/动态规划","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://xuzhengtong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"如何薅到oracle羊毛","slug":"v2ray/v2ray-use1","date":"2020-12-13T05:27:42.000Z","updated":"2020-12-13T05:27:42.000Z","comments":true,"path":"2020/12/13/v2ray/v2ray-use1/","link":"","permalink":"https://xuzhengtong.com/2020/12/13/v2ray/v2ray-use1/","excerpt":"前言Oracle Cloud 承诺如下服务永久免费：概括起来就是：两台 入门服务器 、两块硬盘一共100G、10G对象存储和10G归档存储、两个oracle数据库、","text":"前言Oracle Cloud 承诺如下服务永久免费：概括起来就是：两台 入门服务器 、两块硬盘一共100G、10G对象存储和10G归档存储、两个oracle数据库、一个负载均衡（如果不嫌麻烦，可以结合这个与两台服务器组建v2ray负载网络，充分利用资源，个人用达不到那么高的负载，卖出去也是违法的，所以可以为了学习这么搞）以及每月10T的流量，超出后的流量大概几分钱&#x2F;GB。 开始前准备注册账号需要梯子+双币信用卡。梯子去github找，信用卡实测招行万事通国际信用卡可以，其他银行签发的visa应该也问题不大。注意Home Region的选择，一般亚太区域的机房就可以满足需求。 然鹅，很多人可能就卡在注册这一步了。。。 创建VM选择一个操作系统，注意保存私钥用于登录，然后点击创建。 操作系统配置 使用xshell等工具使用私钥远程登入vm，注意用户不是root，为：opc。 sudo -i 切换到root。若要使用root用户登录，并使用密码验证，请切换到root用户并修改/etc/ssh/sshd_config文件： 12PermitRootLogin yesPasswordAuthentication yes 安装 docker 123yum install -y dockerSystemctl start dockerSystemctl enable docker 关闭 seLinux 修改 /etc/selinux/config 文件中 SELINUX=disabled 防火墙放通 443 端口 12firewall-cmd --zone=public --add-port=443/tcp --permanentfirewall-cmd --reload 完成以上步骤重启一下。 1reboot 出入站规则配置 入站放通443 出站放通所有 组建v2ray+ws+nginx+tls代理创建docker桥接网络在本组建方式中，通过nginx转发访问v2ray，所以v2ray不需要对外暴露端口，v2ray和nginx通过容器互联访问： 1docker network create -d bridge v2ray-net v2ray 在/etc/v2ray/目录下创建config.json文件，内容如下： 12345678910111213141516171819202122232425262728293031323334&#123; &quot;log&quot;: &#123; &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;, &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;, &quot;loglevel&quot;: &quot;warning&quot; &#125;, &quot;inbounds&quot;: [ &#123; &quot;port&quot;: 14641, &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: &#123; &quot;clients&quot;: [ &#123; &quot;id&quot;: &quot;UUID填在这里&quot;, &quot;level&quot;: 1, &quot;alterId&quot;: 64 &#125; ] &#125;, &quot;streamSettings&quot;: &#123; &quot;network&quot;: &quot;ws&quot;, &quot;wsSettings&quot;: &#123; &quot;path&quot;: &quot;/ray&quot; &#125; &#125; &#125; ], &quot;outbounds&quot;: [ &#123; &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: &#123;&#125; &#125; ]&#125; 替换上面的uuid，此项为登录凭证。UUID 生成器 启动v2ray，注意v2ray的版本，这里使用了一个相对比较旧的版本。新版本功能虽然比较多，bug更多了。新版本docker image迁移到：v2fly&#x2F;v2ray-core 1docker run -d --name v2ray --network v2ray-net -v /etc/v2ray/:/etc/v2ray/ -v /etc/localtime:/etc/localtime v2ray/official nginx + tls 首先准备域名和证书，并配置域名解析到你的vm。 创建 /etc/nginx.server.conf/ 目录，并放入证书和如下Nginx配置文件server.conf：其中server_name替换为域名，172.18.0.2 替换为v2ray容器v2ray-net网络IP 12345678910111213141516171819202122server &#123; listen 443 ssl http2 default_server; server_name vps.xuzhengtong.com; root /usr/share/nginx/html; ssl_certificate &quot;/etc/nginx/conf.d/1_vps.xuzhengtong.com_bundle.crt&quot;; ssl_certificate_key &quot;/etc/nginx/conf.d/2_vps.xuzhengtong.com.key&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; proxy_redirect off; proxy_pass http://172.18.0.2:14641/ray; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $http_host; &#125;&#125; 启动Nginx 1docker run -d --name v2rayNginx --network v2ray-net -p 443:443 -v /etc/nginx.server.conf/:/etc/nginx/conf.d -v /etc/localtime:/etc/localtime nginx 客户端连接 测试谷歌和下载速度：谷歌： 连接延迟： 下载速度：","categories":[{"name":"v2ray","slug":"v2ray","permalink":"https://xuzhengtong.com/categories/v2ray/"}],"tags":[{"name":"v2ray","slug":"v2ray","permalink":"https://xuzhengtong.com/tags/v2ray/"}]},{"title":"使用Jenkins自动化构建GitHub Pages","slug":"blog-create-use/auto-build","date":"2020-07-05T05:28:50.000Z","updated":"2020-07-05T05:28:50.000Z","comments":true,"path":"2020/07/05/blog-create-use/auto-build/","link":"","permalink":"https://xuzhengtong.com/2020/07/05/blog-create-use/auto-build/","excerpt":"前言我们进行文章写作，更多的时候不想去关注构建的事情，然而，使用hexo和GitHub必然需要build并push到GitHub pages。使用JenKins可以将构建从写作的步骤中拆除。","text":"前言我们进行文章写作，更多的时候不想去关注构建的事情，然而，使用hexo和GitHub必然需要build并push到GitHub pages。使用JenKins可以将构建从写作的步骤中拆除。 安装Jenkins启动方式 方式一：直接运行war（内置了jetty，需首先安装JDK） 1java -jar jenkins.war 方式二：使用Tomcat:将jenkins.war存放至webapps目录，启动tomcat即可。（同样需要JDK胡或者JRE环境） 方式三：docker建议去Docker Hub检查一下最新版镜像，某些插件依赖最新版本 12docker pull jenkins/jenkins:2.235.1-lts-centos7docker run --name jenkins -p 8080:8080 -p 50000:50000 -e TZ=Asia/Shanghai -v /usr/local/jenkins/data:/var/jenkins_home 08b8cad08fb 配置从日志或者/usr/local/jenkins/data//secrets/initialAdminPassword中获取admin初始密码 后续安装插件的步骤可以跳过或者默认安装即可。建议新建一个用户，就不需要每次都使用admin用户登陆了。 插件需要安装Git、GitHub和NodeJS插件 Git安装Git插件的时候，一般会自动安装Git Client，如果没有的话，需要自行安装Git，插件配置保持默认： 注意配置Git userName和Email 以及 ssh私钥（jenkins）和公钥（GitHub后台），这里不在多讲。 NodeJS GitHubGitHub插件没有什么需要特别配置的东西，记一下webHook地址： GitHub在GitHub上新建一个仓库，用于存放项目源码，并配置钩子： 创建 Jenkins Job 备注：npm run deploy 现在只需写一篇文章并push到GitHub就可以了","categories":[{"name":"个人博客创建及使用","slug":"个人博客创建及使用","permalink":"https://xuzhengtong.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://xuzhengtong.com/tags/Jenkins/"}]},{"title":"Spring Cloud Netflix 服务部署（十 一）","slug":"microservices/spring-cloud-netflix/deploy","date":"2020-01-07T14:36:42.000Z","updated":"2020-01-07T14:36:42.000Z","comments":true,"path":"2020/01/07/microservices/spring-cloud-netflix/deploy/","link":"","permalink":"https://xuzhengtong.com/2020/01/07/microservices/spring-cloud-netflix/deploy/","excerpt":"概述在进行此节之前，确保你以能够熟练使用docker，并对CIDR无分类编址有一定了解。","text":"概述在进行此节之前，确保你以能够熟练使用docker，并对CIDR无分类编址有一定了解。 docker overlay网络跨主机通信的一点探究 子网超网 目前，我们已经收获了八个服务： 这里6、7、8将采用doeker集群部署，1、2、3、4、5将采用独立服务的方式部署。结构如下： 环境准备准备三台性能好一点的服务器，这里使用的是vm虚拟机，centos7系统 manager：管理节点，ip：192.168.112.128 worker1：工作节点，ip：192.168.112.133 worker2：工作节点，ip：192.168.112.132 创建集群在管理节点初始化集群 1docker swarm init --advertise-addr 192.168.112.128 在工作节点加入集群 1docker swarm join --token SWMTKN-1-13mv6nll4ymptpp0jdmc3ou4my6uqohkucpnn8zv9b16rda7fv-0dezqs5g36rocxsx38z35uzla 192.168.112.128:2377 创建自定义的overlay网络1docker network create -d overlay --subnet=206.35.199.0/24 --gateway=206.35.199.1 --ip-range 206.35.199.128/25 --attachable cloud-network –ip-range：表示随机分配的ip将在128~255范围内指定，包括Endpoint的端点IP。主要目的是因为我在创建这个网络之前就已经完成了项目的相关地址配置（如eureka:206.35.199.2），为了防止Endpoint使用到项目配置的这些地址而引起IP地址冲突，将随机分配的范围指定在此网段的后半部分。 搭建镜像项目地址 服务 地址 Eureka 206.35.199.2 Config 206.35.199.3 Zipkin 206.35.199.4 Spring Boot Admin 206.35.199.5 Zuul 206.35.199.6 其它 随机 这里需要指定eureka、config、zipKin的地址。完成之后修改项目为发行版（RELEASE），项目源码：https://github.com/intxzt/spring-cloud-netflix.git 使用dockerFile构建镜像DockerFile以eureka为例 1234FROM openjdk:8COPY cloud-eureka-service-1.0.0-RELEASE.jar /usr/local/jar/WORKDIR /usr/local/jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;cloud-eureka-service-1.0.0-RELEASE.jar&quot;] 1docker build -t eureka . 这里我已将所有的镜像上传至阿里云镜像仓库： 服务名 仓库地址 eureka registry.cn-hangzhou.aliyuncs.com&#x2F;intxzt&#x2F;eureka config registry.cn-hangzhou.aliyuncs.com&#x2F;intxzt&#x2F;config sleuth（Spring Boot Admin） registry.cn-hangzhou.aliyuncs.com&#x2F;intxzt&#x2F;sleuth zuul registry.cn-hangzhou.aliyuncs.com&#x2F;intxzt&#x2F;zuul admin-server registry.cn-hangzhou.aliyuncs.com&#x2F;intxzt&#x2F;admin-server feign-server registry.cn-hangzhou.aliyuncs.com&#x2F;intxzt&#x2F;feign-server ribbon-server registry.cn-hangzhou.aliyuncs.com&#x2F;intxzt&#x2F;ribbon-server 部署 Zipkin服务链路追踪（worker1） 1docker run -p 9411:9411 --ip 206.35.199.4 --network cloud-network -d --name zipkin openzipkin/zipkin eureka注册中心（manager） 1docker run -p 80:8761 --network cloud-network --ip 206.35.199.2 -d --name eureka registry.cn-hangzhou.aliyuncs.com/intxzt/eureka config配置中心（manager） 1docker run -p 8888:8888 --network cloud-network --ip 206.35.199.3 -d --name config registry.cn-hangzhou.aliyuncs.com/intxzt/config sleuth——Spring Boot Admin（worker1） 1docker run -p 8084:8084 --network cloud-network --ip 206.35.199.5 -d --name sleuth registry.cn-hangzhou.aliyuncs.com/intxzt/sleuth zuul网关（worker2） 1docker run -p 8769:8769 --network cloud-network --ip 206.35.199.6 -d --name zuul registry.cn-hangzhou.aliyuncs.com/intxzt/zuul admin-server（manager） 1docker service create --replicas 3 --network cloud-network --name admin-server registry.cn-hangzhou.aliyuncs.com/intxzt/admin-server ribbon-server（manager） 1docker service create --replicas 3 --network cloud-network --name ribbon-server registry.cn-hangzhou.aliyuncs.com/intxzt/ribbon-server feign-server（manager） 1docker service create --replicas 3 --network cloud-network --name feign-server registry.cn-hangzhou.aliyuncs.com/intxzt/feign-server 注意：在括号内标识的节点执行shell命令，服务分布见图deploy-2；6、7、8并没有对外映射端口，需通过zuul网关统一访问。 测试部署完成之后，可以通过网关访问之前测试过的接口。zipkin、eureka、Spring Boot Admin如下：","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://xuzhengtong.com/tags/docker/"},{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"}]},{"title":"docker overlay网络跨主机通信的一点探究","slug":"docker/docker-overlay-network","date":"2020-01-05T02:58:38.000Z","updated":"2020-01-05T02:58:38.000Z","comments":true,"path":"2020/01/05/docker/docker-overlay-network/","link":"","permalink":"https://xuzhengtong.com/2020/01/05/docker/docker-overlay-network/","excerpt":"ingress overlay网络以下是来至官方文档——Use overlay networks 的一段","text":"ingress overlay网络以下是来至官方文档——Use overlay networks 的一段 When you initialize a swarm or join a Docker host to an existing swarm, two new networks are created on that Docker host: an overlay network called ingress, which handles control and data traffic related to swarm services. When you create a swarm service and do not connect it to a user-defined overlay network, it connects to the ingress network by default. a bridge network called docker_gwbridge, which connects the individual Docker daemon to the other daemons participating in the swarm. 大致意思就是说ingress是集群服务默认使用的overlay网络，用于处理与集群服务有关的控制（负载）和数据流量。 在容器内的应用无法使用此网络进行通信，比如：在只有一个leader的集群上开两个服务：tomcatv1和tomcatv2，以交互的方式进入tomcatv2，并使用此网络去请求tomcat的8080端口，是无法访问的（即便两个IP能够ping通） 创建两个tomcat服务 12docker service create -p 8080:8080 --name tomcatv1 tomcatdocker service create -p 80:8080 --name tomcatv2 tomcat 交互进入tomcatv2： 1docker exec -it tomcatv2.1.i5v2a2vnocgxguoup6fh7jt55 bash 请求tomcatv1： 12345678//pingroot@3a5b888f644a:/usr/local/tomcat# ping 10.255.0.18PING 10.255.0.18 (10.255.0.18) 56(84) bytes of data.64 bytes from 10.255.0.18: icmp_seq=1 ttl=64 time=0.067 ms64 bytes from 10.255.0.18: icmp_seq=2 ttl=64 time=0.080 ms//curl 这里不会有任何结果，可以和 curl localhost:8080 对比一下结果root@3a5b888f644a:/usr/local/tomcat# curl localhost:8080 自定义overlay网络 Prerequisites: Firewall rules for Docker daemons using overlay networks You need the following ports open to traffic to and from each Docker host participating on an overlay network: TCP port 2377 for cluster management communications TCP and UDP port 7946 for communication among nodes UDP port 4789 for overlay network traffic Before you can create an overlay network, you need to either initialize your Docker daemon as a swarm manager using docker swarm init or join it to an existing swarm using docker swarm join. Either of these creates the default ingress overlay network which is used by swarm services by default. You need to do this even if you never plan to use swarm services. Afterward, you can create additional user-defined overlay networks. 两个先决条件：宿主机加入集群和配置防火墙规则（测试使用直接关闭就行） 创建注意：必须是集群管理节点 1docker network create -d overlay my-overlay 这里给出部分参数说明： 名称 描述 –attachable 独立容器也能使用此网络 –driver , -d 网络驱动 –subnet 网段的CIDR格式的子网 –gateway 主子网的IPv4或IPv6网关 –ingress 自定义ingress类型的时候指定，只能有一个ingress网络 –ip-range 从子范围（相对于子网）分配容器ip 更多参数参见：docker network create 测试这次使用创建的my-overlay网络启动服务 12docker service create -p 8080:8080 --network my-overlay --name tomcatv1 tomcatdocker service create -p 80:8080 --network my-overlay --name tomcatv2 tomcat 进入tomcatv2通过my-overlay请求tomcatv1的8080端口 123//这里404的原因是我拉取的tomcat镜像webapps下没有任何东西root@48b4ca6c276c:/usr/local/tomcat# curl 10.0.0.3:8080&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;title&gt;HTTP Status 404 – Not Found&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;font-family:Tahoma,Arial,sans-serif;&#125; h1, h2, h3, b &#123;color:white;background-color:#525D76;&#125; h1 &#123;font-size:22px;&#125; h2 &#123;font-size:16px;&#125; h3 &#123;font-size:14px;&#125; p &#123;font-size:12px;&#125; a &#123;color:black;&#125; .line &#123;height:1px;background-color:#525D76;border:none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;HTTP Status 404 – Not Found&lt;/h1&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;p&gt;&lt;b&gt;Type&lt;/b&gt; Status Report&lt;/p&gt;&lt;p&gt;&lt;b&gt;Message&lt;/b&gt; Not found&lt;/p&gt;&lt;p&gt;&lt;b&gt;Description&lt;/b&gt; The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.&lt;/p&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;h3&gt;Apache Tomcat/8.5.50&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 发现，服务间已能通过此网络正常访问。 注意：当管理节点创建的服务被部署到工作节点，或者工作节点使用此网络部署独立的服务（docker run -p 8080:8080 --network my-overlay -d --name tomcat tomcat）,工作节点会在此网络（my-overlay）自动创建一个端点（Endpoint），用于连接工作节点所在宿主机与其他集群内的宿主机。该端点（Endpoint）将占用此网络（my-overlay）一个随机的IP地址。 Docker 网络模型如下：","categories":[{"name":"docker","slug":"docker","permalink":"https://xuzhengtong.com/categories/docker/"},{"name":"网络配置","slug":"docker/网络配置","permalink":"https://xuzhengtong.com/categories/docker/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://xuzhengtong.com/tags/docker/"}]},{"title":"子网、超网","slug":"internet/network","date":"2020-01-03T04:48:26.000Z","updated":"2020-01-03T04:48:26.000Z","comments":true,"path":"2020/01/03/internet/network/","link":"","permalink":"https://xuzhengtong.com/2020/01/03/internet/network/","excerpt":"子网在ARPANET的早期，IP地址被设计为“分类的IP地址”，就是将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中一个字段是网络号（net-id），它标识主机（或路由器）所连接到的网络。第二个字段是主机号（host-id），它标识该主机（或路由器）。","text":"子网在ARPANET的早期，IP地址被设计为“分类的IP地址”，就是将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中一个字段是网络号（net-id），它标识主机（或路由器）所连接到的网络。第二个字段是主机号（host-id），它标识该主机（或路由器）。如下图所示： 从现在看来，这样的设计并不合理，每一个A类地址网络可连接的最大主机数有16777214(2^24-2)个，B类的地址网络可连接的最大主机数也有65534（2^16-2）个，然而有些网络对接在网络上的主机有限制，根本达不到这样大的数值。有的单位申请到了一个B类地址网络，但所连接的主机数并不多，可是又不愿意申请一个足够使用的C类地址，理由是考虑到未来可能的发展。等等的这些情况造成了IP地址空间的利用率并不高。 为了解决分类的IP地址所带来的各种问题，从1985年起在IP地址中又增加了一个子网号字段，使两级IP地址变成了三级IP地址。这种做法叫做划分子网法 两级IP$$IP ::&#x3D;{&lt;网络号&gt;&lt;主机号&gt;}$$三级IP$$IP ::&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}$$划分子网将从网络的主机号借若干位，当其他网络发送给本单位某个主机的IP数据报，将根据IP数据报的目标网络号找到连接在本单位网络上的路由器，然后路由器根据网络号和子网号找到目标子网，再把IP数据报交付给目标主机。 接下来就只有一个问题了：路由器是如何将数据报转发到子网的？例如路由器IP：145.13.0.0，目标IP：145.14.3.15，如何将它转发到子网145.14.3.0 由此引出了另外一个概念——子网掩码，如下图所示，将目标IP（145.14.3.15）与子网掩码（255.255.255.0）相与，可以很轻易的得出子网地址：145.14.3.0 无分类编址CIDR(构成超网)CIDR最主要的特点有两个： 消除了传统的A类、B类、C类地址及划分子网的概念，因而可以更加有效的分配IPv4的地址空间。CIDR把32位的IP地址划分为两个部分，前面的部分是网络前缀（network-prefix），用来指明网络，后面的部分则用来指明主机$$IP ::&#x3D;{&lt;网络前缀&gt;&lt;主机号&gt;}$$CIDR把网络前缀都相同的连续IP地址组成一个CIDR地址块，即在IP地址后加上斜线”&#x2F;“，然后写上网络前缀所占位数。 我们只要知道CIDR地址块中任何一个地址，就知道这个地址块的最小地址和最大地址，如： 128.14.35.7&#x2F;24，最小地址：128.14.35.0；最大地址：128.14.35.255 128.14.35.7&#x2F;20，35的二进制表示：00100011，取其前4（20-16）位，后四位补0，得00100000：32，即最小地址：128.14.32.0；最大地址后四位补1，得00101111:47，即最大地址：128.14.47.255 主机号全是0和1的地址一般并不使用。 下图是常用的CIDR地址块，可以看出每一个CIDR地址块的地址数一定是2的整数次幂，除了最后几行外，CIDR地址块包含了多个C类地址（是一个C类地址的2^n倍），这就是构成超网这一名词的来源。 参考及摘选书籍： [1]谢希仁.计算机网络[M].北京:电子工业出版社,2013.","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xuzhengtong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络层","slug":"网络层","permalink":"https://xuzhengtong.com/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"}]},{"title":"Spring Cloud Netflix Spring boot admin服务监控（十）","slug":"microservices/spring-cloud-netflix/admin","date":"2019-12-31T15:13:11.000Z","updated":"2019-12-31T15:13:11.000Z","comments":true,"path":"2019/12/31/microservices/spring-cloud-netflix/admin/","link":"","permalink":"https://xuzhengtong.com/2019/12/31/microservices/spring-cloud-netflix/admin/","excerpt":"概述随着开发周期的推移，项目会不断变大，切分出的服务也会越来越多，这时一个个的微服务构成了错综复杂的系统。对于各个微服务系统的健康状态、会话数量、并发数、服务资源、延迟等度量信息的收集就成为了一个挑战。","text":"概述随着开发周期的推移，项目会不断变大，切分出的服务也会越来越多，这时一个个的微服务构成了错综复杂的系统。对于各个微服务系统的健康状态、会话数量、并发数、服务资源、延迟等度量信息的收集就成为了一个挑战。 Spring Boot ActuatorActuator是Spring Boot的模块，它在应用中添加了REST&#x2F;JMS端点，方便监控和管理应用。端点提供了健康检查、指标监控、访问日志、线程转储、堆转储和环境信息等等。 Spring Boot AdminActuator功能强大，便于其他应用使用端点（只需要简单的REST调用）。但是开发人员使用时就没那么方便了。对于开发人员，有良好的交互界面会更方便浏览监控数据和管理应用。这正是Spring Boot Admin做的工作。它为actuator端点提供了良好的交互界面，并提供了额外的特性。 Spring Boot Admin 有两个角色组成，一个是 Spring Boot Admin Server，一个是 Spring Boot Admin Client。 创建Spring Boot Admin服务端 完整pom文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xzt&lt;/groupId&gt; &lt;artifactId&gt;cloud-sleuth-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-sleuth-service&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot-admin.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要是增加了spring-boot-admin-starter-server依赖 1234&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;&lt;/dependency&gt; Application1234567891011121314151617package com.xzt.sleuth;import de.codecentric.boot.admin.server.config.EnableAdminServer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClient@EnableAdminServerpublic class CloudSleuthServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudSleuthServiceApplication.class, args); &#125;&#125; bootstrap.yml123456789101112spring: cloud: config: name: public-config,sleuth-config label: master profile: dev uri: http://localhost:8888eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 注意这里是使用指定url的方式取配置中心拉取配置文件。如果使用通过eureka获取配置中心地址并拉取配置文件的方式，我这里出现了一个问题：在spring-boot-admin-server之后注册到eureka的服务无法被spring-boot-admin-server获取到，原因未知。下面给出我的版本和配置的相关信息： spring-boot-admin-starter-server:2.2.1 spring-cloud:Hoxton.SR1 spring-boot:2.2.2.RELEASE 1234567891011121314spring: cloud: config: name: public-config,sleuth-config label: master profile: dev discovery: enabled: true service-id: cloud-config-serviceeureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ git仓库配置文件public-config-dev.yml&amp;配置中心和注册中心的application.ymlpublic-config-dev.yml：所有的项目都要读取的公共配置文件 12345678management: endpoints: web: exposure: include: &quot;*&quot; endpoint: health: show-details: always management.endpoints.web.exposure.include=*，Actuator默认只公开了/health和/info端点，要想暴露所有端点只需设置成星号即可 注意：.yml结尾的配置文件，*需要加“” sleuth-config-dev.yml123456spring: application: name: cloud-sleuth-serviceserver: port: 8084 测试依次启动，zipkin-server，eureka，config，spring boot admin，admin-service，访问：http://localhost:8084 总结尽管Spring Boot Admin不是Spring团队提供的模块，但是就其使用频率和使用的舒适度以及兼容性等方面考虑，它可以称的上是管理和监控Spring Boot的最好的开源项目。 在与Spring cloud 结合的方面，Spring Boot Admin Service将通过注册中心拉取应用信息，无需SBA客户端，下面是引用官网的一段： If you already use Spring Cloud Discovery for your applications you don’t need the SBA Client. Just add a DiscoveryClient to Spring Boot Admin Server, the rest is done by our AutoConfiguration. The following steps uses Eureka, but other Spring Cloud Discovery implementations are supported as well. There are examples using Consul and Zookeeper. Also have a look at the Spring Cloud documentation. Add spring-cloud-starter-eureka to you dependencies: pom.xml 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; Enable discovery by adding @EnableDiscoveryClient to your configuration: 123456789101112131415161718192021@Configuration @EnableAutoConfiguration @EnableDiscoveryClient @EnableAdminServer public class SpringBootAdminApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootAdminApplication.class, args); &#125; /** * For the sake of brevity we’re disabling the security for now. Have a look at the security section on how to deal with secured endpoints. */ @Configuration public static class SecurityPermitAllConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().anyRequest().permitAll() .and().csrf().disable(); &#125; &#125; &#125; Tell the Eureka client where to find the service registry: application.yml 12345678910111213141516171819#Configuration section for the Eureka clienteureka: instance: leaseRenewalIntervalInSeconds: 10 health-check-url-path: /actuator/health client: registryFetchIntervalSeconds: 5 serviceUrl: defaultZone: $&#123;EUREKA_SERVICE_URL:http://localhost:8761&#125;/eureka/ #As with Spring Boot 2 most of the endpoints aren’t exposed via http by default, we expose all of them. For production you should carefully choose which endpoints to expose.management: endpoints: web: exposure: include: &quot;*&quot; endpoint: health: show-details: ALWAYS","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"Spring boot admin","slug":"Spring-boot-admin","permalink":"https://xuzhengtong.com/tags/Spring-boot-admin/"}]},{"title":"Spring Cloud Netflix ZipKin服务链路追踪（九）","slug":"microservices/spring-cloud-netflix/zipkin","date":"2019-12-31T11:03:23.000Z","updated":"2019-12-31T11:03:23.000Z","comments":true,"path":"2019/12/31/microservices/spring-cloud-netflix/zipkin/","link":"","permalink":"https://xuzhengtong.com/2019/12/31/microservices/spring-cloud-netflix/zipkin/","excerpt":"ZipKin概述ZipKin 是一个开放源代码的分布式跟踪系统，由 Twitter 公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。它的理论模型来自于 Google Dapper 论文。","text":"ZipKin概述ZipKin 是一个开放源代码的分布式跟踪系统，由 Twitter 公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。它的理论模型来自于 Google Dapper 论文。 每个服务向 ZipKin 报告计时数据，ZipKin 会根据调用关系通过 ZipKin UI 生成依赖关系图，显示了多少跟踪请求通过每个服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。 服务追踪说明 微服务架构是通过业务来划分服务的，使用 REST 调用。对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。 随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下： 术语解释 Span：基本工作单元，例如，在一个新建的 Span 中发送一个 RPC 等同于发送一个回应请求给 RPC，Span 通过一个 64 位 ID 唯一标识，Trace 以另一个 64 位 ID 表示。 Trace：一系列 Spans 组成的一个树状结构，例如，如果你正在运行一个分布式大数据工程，你可能需要创建一个 Trace。 Annotation：用来即使记录一个事件的存在，一些核心 Annotations 用来定义一个请求的开始和结束 cs：Client Sent，客户端发起一个请求，这个 Annotation 描述了这个 Span 的开始 sr：Server Received，服务端获得请求并准备开始处理它，如果将其 sr 减去 cs 时间戳便可得到网络延迟 ss：Server Sent 表明请求处理的完成(当请求返回客户端)，如果 ss 减去 sr 时间戳便可得到服务端需要的处理请求时间 cr：Client Received 表明 Span 的结束，客户端成功接收到服务端的回复，如果 cr 减去 cs 时间戳便可得到客户端从服务端获取回复的所有所需时间 将 Span 和 Trace 在一个系统中使用 Zipkin 注解的过程图形化： 创建 ZipKin 服务端这里踩了很多坑，本来是采用新建一个项目，并使用 io.zipkin.java:zipkin、io.zipkin.java:zipkin-server、io.zipkin.java:zipkin-autoconfigure-ui 来构建，但是，首先遇到的一个问题就是日志框架的冲突问题，严重到无法运行，接下来又是一个The bean &#39;characterEncodingFilter&#39;, could not be registered.的问题。我到这里就止步了，感觉自建server的方式不太稳定。希望或者需要使用这种方式的自行搜索解决问题吧。 官方给出的三种方案： DockerThe Docker Zipkin project is able to build docker images, provide scripts and a docker-compose.yml for launching pre-built images. The quickest start is to run the latest image directly: 1docker run -d -p 9411:9411 openzipkin/zipkin JavaIf you have Java 8 or higher installed, the quickest way to get started is to fetch the latest release（jar包的下载连接，如果失效请去 官网下载） as a self-contained executable jar: 12curl -sSL https://zipkin.io/quickstart.sh | bash -sjava -jar zipkin.jar Running from SourceZipkin can be run from source if you are developing new features. To achieve this, you’ll need to get Zipkin’s source and build it. 1234567# get the latest sourcegit clone https://github.com/openzipkin/zipkincd zipkin# Build the server and also make its dependencies./mvnw -DskipTests --also-make -pl zipkin-server clean install# Run the serverjava -jar ./zipkin-server/target/zipkin-server-*exec.jar 追踪服务在 所有需要被追踪的项目 中增加 spring-cloud-starter-zipkin 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; 默认配置为http://localhost:9411。如果要更换ip，在public.yml(公共配置文件)和注册中心与配置中心的application.yml追加如下配置： 123spring: zipkin: base-url: http://localhost:9411 注意：以eureka为例，在第一次请求eureka控制面板，或者第一次向eureka注册时，eureka会去请求追踪服务器（http://localhost:9411/api/v2/spans）,所以追踪服务器至少应在eureka启动之后立即启动。对于开启了自注册的eureka，追踪服务器应当优先启动。 测试依次启动，zipkin-server，eureka，config，feign，admin-service，多次请求feign接口","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"ZipKin","slug":"ZipKin","permalink":"https://xuzhengtong.com/tags/ZipKin/"}]},{"title":"Spring Cloud Netflix 分布式配置中心（八）","slug":"microservices/spring-cloud-netflix/config","date":"2019-12-27T05:25:42.000Z","updated":"2019-12-27T05:25:42.000Z","comments":true,"path":"2019/12/27/microservices/spring-cloud-netflix/config/","link":"","permalink":"https://xuzhengtong.com/2019/12/27/microservices/spring-cloud-netflix/config/","excerpt":"概述在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在 Spring Cloud 中，有分布式配置中心组件 Spring Cloud Config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程 Git 仓库中。在 Spring Cloud Config 组件中，分两个角色，一是 Config Server，二是 Config Client。","text":"概述在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在 Spring Cloud 中，有分布式配置中心组件 Spring Cloud Config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程 Git 仓库中。在 Spring Cloud Config 组件中，分两个角色，一是 Config Server，二是 Config Client。 以下以网关为例，开始演示Config Server和Config Client的配置。 Config Server创建工程 pom依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xzt&lt;/groupId&gt; &lt;artifactId&gt;cloud-config-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-config-service&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 启动类通过 @EnableConfigServer 注解，开启配置服务器功能 1234567891011121314151617package com.xzt.config;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClient@EnableConfigServerpublic class CloudConfigServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudConfigServiceApplication.class, args); &#125;&#125; application.yml这里使用git仓库的方式 12345678910111213141516171819202122232425262728spring: application: name: cloud-config-service cloud: config: label: master server: git: uri: https://github.com/intxzt/spring-cloud-netflix-config.git search-paths: repo username: password:# 本地# profiles:# active: native #Comma-separated list of active profiles. Can be overridden by a command line switch.# cloud:# config:# server:# native:# search-locations: classpath:/configserver: port: 8888eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 相关配置说明，如下： spring.cloud.config.label：配置仓库的分支 spring.cloud.config.server.git.uri：配置 Git 仓库地址（GitHub、GitLab、码云 …） spring.cloud.config.server.git.search-paths：配置仓库路径（存放配置文件的目录） spring.cloud.config.server.git.username：访问 Git 仓库的账号 spring.cloud.config.server.git.password：访问 Git 仓库的密码 测试浏览器访问http://localhost:8888/admin-config/dev/master显示如下内容 123456789101112131415161718&#123; &quot;name&quot;: &quot;admin-config&quot;, &quot;profiles&quot;: [ &quot;dev&quot; ], &quot;label&quot;: &quot;master&quot;, &quot;version&quot;: &quot;96c75fddffe2f06cbd478ce73bb089e33690b630&quot;, &quot;state&quot;: null, &quot;propertySources&quot;: [ &#123; &quot;name&quot;: &quot;https://github.com/intxzt/spring-cloud-netflix-config.git/repo/admin-config-dev.yml&quot;, &quot;source&quot;: &#123; &quot;spring.application.name&quot;: &quot;cloud-admin-service&quot;, &quot;server.port&quot;: 8762 &#125; &#125; ]&#125; Config Client增加pom依赖1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 删除application.yml 新增bootatrap.yml为了使用Config Server中配置启动网关，需要使用加载顺序更加靠前的bootatrap.yml 1234567891011121314spring: cloud: config: discovery: enabled: true #Flag to indicate that config server discovery is enabled (config server URL will be looked up via discovery). service-id: cloud-config-service name: zuul-config label: master profile: deveureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 相关配置说明，如下： spring.cloud.config.discovery.enable：指示已启用配置服务器发现的标志（将通过发现查找配置服务器URL） spring.cloud.config.discovery.service-id：eureka中配置中心的id spring.cloud.config.uri：配置服务中心的网址 spring.cloud.config.name：配置文件名称的前缀 spring.cloud.config.label：配置仓库的分支 spring.cloud.config.profile：配置文件的环境标识 dev：表示开发环境 test：表示测试环境 prod：表示生产环境 注意事项： 配置服务器的默认端口为 8888，如果修改了默认端口，则客户端项目就不能在 application.yml 或 application.properties 中配置 spring.cloud.config.uri，必须在 bootstrap.yml 或是 bootstrap.properties 中配置，原因是 bootstrap 开头的配置文件会被优先加载和配置，切记。 这里使用eureka服务发现配置中心。所以并未指定url。 如果Config Server是本地模式，可不用指定label，规则如下： 对于zuul-config-dev.yml，需要配置spring.cloud.config.name=zuul-config和spring.cloud.config.profile=dev git仓库zuul-config-dev.yml123456789101112spring: application: name: spring-cloud-zuulserver: port: 8769zuul: routes: api-1: path: /admin/** serviceId: cloud-admin-service 测试依次启动注册中心、配置中心、和网关，访问http://localhost:8769/admin/hi?message=HelloRibbon,出现以下内容 1&#123;&quot;message&quot;:&quot;无法连接，请检查您的网络&quot;,&quot;status&quot;:200&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"}]},{"title":"Spring Cloud Netflix 使用熔断器仪表盘监控（七）","slug":"microservices/spring-cloud-netflix/fuse-dashboard","date":"2019-12-24T05:55:36.000Z","updated":"2019-12-24T05:55:36.000Z","comments":true,"path":"2019/12/24/microservices/spring-cloud-netflix/fuse-dashboard/","link":"","permalink":"https://xuzhengtong.com/2019/12/24/microservices/spring-cloud-netflix/fuse-dashboard/","excerpt":"概述在 Ribbon 和 Feign 项目增加 Hystrix 仪表盘功能，两个项目的改造方式相同","text":"概述在 Ribbon 和 Feign 项目增加 Hystrix 仪表盘功能，两个项目的改造方式相同 添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 启动类添加@EnableHystrixDashboard注解 12345678910111213141516171819package com.xzt.feign;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClients@EnableEurekaClient@EnableHystrixDashboardpublic class CloudFeignServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudFeignServiceApplication.class, args); &#125;&#125; 创建 hystrix.stream 的 Servlet 配置12345678910111213141516171819package com.xzt.feign.config;import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class HystrixDashboardConfiguration &#123; @Bean public ServletRegistrationBean&lt;HystrixMetricsStreamServlet&gt; getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean&lt;HystrixMetricsStreamServlet&gt; registrationBean = new ServletRegistrationBean&lt;&gt;(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean; &#125;&#125; 测试浏览器端访问 http://localhost:8765/hystrix 界面如下： 点击 Monitor Stream，进入下一个界面，访问 http://localhost:8765/hi?message=HelloRibbon 此时会出现监控界面： 附：Hystrix 说明什么情况下会触发 fallback 方法 名字 描述 触发fallback EMIT 值传递 NO SUCCESS 执行完成，没有错误 NO FAILURE 执行抛出异常 YES TIMEOUT 执行开始，但没有在允许的时间内完成 NO BAD_REQUEST 执行抛出HystrixBadRequestException YES SHORT_CIRCUITED 断路器打开，不尝试执行 YES THREAD_POOL_REJECTED 线程池拒绝，不尝试执行 YES SEMAPHORE_REJECTED 信号量拒绝，不尝试执行 YES fallback 方法在什么情况下会抛出异常 名字 描述 抛异常 FALLBACK_EMIT Fallback值传递 NO FALLBACK_SUCCESS Fallback执行完成，没有错误 NO FALLBACK_FAILURE Fallback执行抛出出错 YES FALLBACK_REJECTED Fallback信号量拒绝，不尝试执行 YES FALLBACK_MISSING 没有Fallback实例 YES Hystrix Dashboard 界面监控参数 Hystrix 常用配置信息超时时间（默认1000ms，单位：ms） hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds：在调用方配置，被该调用方的所有方法的超时时间都是该值，优先级低于下边的指定配置 hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutInMilliseconds：在调用方配置，被该调用方的指定方法（HystrixCommandKey 方法名）的超时时间是该值 线程池核心线程数 hystrix.threadpool.default.coreSize：默认为 10 Queue hystrix.threadpool.default.maxQueueSize：最大排队长度。默认 -1，使用 SynchronousQueue。其他值则使用 LinkedBlockingQueue。如果要从 -1 换成其他值则需重启，即该值不能动态调整，若要动态调整，需要使用到下边这个配置 hystrix.threadpool.default.queueSizeRejectionThreshold：排队线程数量阈值，默认为 5，达到时拒绝，如果配置了该选项，队列的大小是该队列 注意： 如果 maxQueueSize=-1 的话，则该选项不起作用 断路器 hystrix.command.default.circuitBreaker.requestVolumeThreshold：当在配置时间窗口内达到此数量的失败后，进行短路。默认 20 个（10s 内请求失败数量达到 20 个，断路器开） hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds：短路多久以后开始尝试是否恢复，默认 5s hystrix.command.default.circuitBreaker.errorThresholdPercentage：出错百分比阈值，当达到此阈值后，开始短路。默认 50% fallback hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests：调用线程允许请求 HystrixCommand.GetFallback() 的最大数量，默认 10。超出时将会有异常抛出，注意：该项配置对于 THREAD 隔离模式也起作用","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"熔断","slug":"熔断","permalink":"https://xuzhengtong.com/tags/%E7%86%94%E6%96%AD/"}]},{"title":"Spring Cloud Netflix 使用熔断器防止服务雪崩（六）","slug":"microservices/spring-cloud-netflix/fuse","date":"2019-12-23T15:23:12.000Z","updated":"2019-12-23T15:23:12.000Z","comments":true,"path":"2019/12/23/microservices/spring-cloud-netflix/fuse/","link":"","permalink":"https://xuzhengtong.com/2019/12/23/microservices/spring-cloud-netflix/fuse/","excerpt":"概述在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以通过 RPC 相互调用，在 Spring Cloud 中可以用 RestTemplate + Ribbon 和 Feign 来调用。","text":"概述在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以通过 RPC 相互调用，在 Spring Cloud 中可以用 RestTemplate + Ribbon 和 Feign 来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证 100% 可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet 容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的 “雪崩” 效应。 为了解决这个问题，业界提出了熔断器模型。 Netflix 开源了 Hystrix 组件，实现了熔断器模式，Spring Cloud 对这一组件进行了整合。在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图： 较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystrix 是 5 秒 20 次） 熔断器将会被打开。 Ribbon添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 启动类添加@EnableHystrix注解 1234567891011121314151617package com.xzt.ribbon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.hystrix.EnableHystrix;@SpringBootApplication@EnableEurekaClient@EnableHystrixpublic class CloudRibbonServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudRibbonServiceApplication.class, args); &#125;&#125; Service 在 Ribbon 调用方法上增加 @HystrixCommand 注解并指定 fallbackMethod 熔断方法 123456789101112131415161718192021222324252627282930313233343536373839package com.xzt.ribbon.test.service;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.xzt.ribbon.test.beans.User;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;@Servicepublic class AdminService &#123; private Logger logger = LoggerFactory.getLogger(AdminService.class); @Autowired private RestTemplate restTemplate; @HystrixCommand(fallbackMethod = &quot;hiError&quot;) public String sayHi(String message) &#123; return restTemplate.getForObject(&quot;http://CLOUD-ADMIN-SERVICE/hi?message=&quot; + message, String.class); &#125; @HystrixCommand(fallbackMethod = &quot;hiErrorPost&quot;) public String postHi(String userName, String password) &#123; User user = new User(); user.setUserName(userName); user.setPassword(password); User res = restTemplate.postForObject(&quot;http://CLOUD-ADMIN-SERVICE/req_post&quot;, user, User.class); return String.format(&quot;%s ,welcome! I am from port %s&quot;, userName, res.getPort()); &#125; public String hiError(String message) &#123; return &quot;Hi，your message is :\\&quot;&quot; + message + &quot;\\&quot; but request error.&quot;; &#125; //参数必须保持一致，否则报错fallback method wasn&#x27;t found: hiErrorPost([class java.lang.String, class java.lang.String]) public String hiErrorPost(String userName,String password) &#123; return &quot;request error.&quot;; &#125;&#125; 测试熔断器此时我们关闭服务提供者，再次请求 http://localhost:8764/hi?message=HelloRibbon 浏览器会显示： 1Hi，your message is :&quot;HelloRibbon&quot; but request error. Feign Feign 是自带熔断器的，但默认是关闭的。需要在配置文件中配置打开它，在配置文件增加以下代码： 123feign: hystrix: enabled: true 创建熔断器类并实现对应的 Feign 接口1234567891011121314151617package com.xzt.feign.test.service;import com.xzt.feign.test.beans.User;import org.springframework.stereotype.Component;@Componentpublic class AdminHystrix implements AdminService &#123; @Override public String sayHi(String message) &#123; return &quot;Hi，your message is :\\&quot;&quot; + message + &quot;\\&quot; but request error.&quot;; &#125; @Override public User postHi(User user) &#123; return null; &#125;&#125; 在 Service 中增加 fallback 指定类123456789101112131415161718package com.xzt.feign.test.service;import com.xzt.feign.test.beans.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@FeignClient(value = &quot;cloud-admin-service&quot;,fallback = AdminHystrix.class)public interface AdminService &#123; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) String sayHi(@RequestParam(value = &quot;message&quot;) String message); @RequestMapping(value = &quot;req_post&quot;, method = RequestMethod.POST) User postHi(@RequestBody User user);&#125; 测试熔断器此时我们关闭服务提供者，再次请求 http://localhost:8765/hi?message=HelloFeign 浏览器会显示： 1Hi，your message is :&quot;HelloRibbon&quot; but request error.","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"熔断","slug":"熔断","permalink":"https://xuzhengtong.com/tags/%E7%86%94%E6%96%AD/"}]},{"title":"Spring Cloud Netflix 创建服务消费者——Feign（五）","slug":"microservices/spring-cloud-netflix/feign","date":"2019-12-23T12:20:29.000Z","updated":"2019-12-23T12:20:29.000Z","comments":true,"path":"2019/12/23/microservices/spring-cloud-netflix/feign/","link":"","permalink":"https://xuzhengtong.com/2019/12/23/microservices/spring-cloud-netflix/feign/","excerpt":"概述Feign 是一个声明式的伪 Http 客户端，它使得写 Http 客户端变得更简单。使用 Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用 Feign 注解和 JAX-RS 注解。Feign 支持可插拔的编码器和解码器。Feign 默认集成了 Ribbon，并和 Eureka 结合，默认实现了负载均衡的效果 Feign 采用的是基于接口的注解 Feign 整合了 ribbon","text":"概述Feign 是一个声明式的伪 Http 客户端，它使得写 Http 客户端变得更简单。使用 Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用 Feign 注解和 JAX-RS 注解。Feign 支持可插拔的编码器和解码器。Feign 默认集成了 Ribbon，并和 Eureka 结合，默认实现了负载均衡的效果 Feign 采用的是基于接口的注解 Feign 整合了 ribbon 创建服务消费者 完整pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xzt&lt;/groupId&gt; &lt;artifactId&gt;cloud-feign-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-feign-service&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml1234567891011spring: application: name: cloud-feign-serviceserver: port: 8765eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 启动类1234567891011121314151617package com.xzt.feign;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClients@EnableEurekaClientpublic class CloudFeignServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudFeignServiceApplication.class, args); &#125;&#125; Service123456789101112131415161718package com.xzt.feign.test.service;import com.xzt.feign.test.beans.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@FeignClient(value = &quot;cloud-admin-service&quot;)public interface AdminService &#123; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) String sayHi(@RequestParam(value = &quot;message&quot;) String message); @RequestMapping(value = &quot;req_post&quot;, method = RequestMethod.POST) User postHi(@RequestBody User user);&#125; Controller1234567891011121314151617181920212223242526272829package com.xzt.feign.test.controller;import com.xzt.feign.test.beans.User;import com.xzt.feign.test.service.AdminService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; @Autowired private AdminService adminService; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam String message) &#123; return adminService.sayHi(message); &#125; @RequestMapping(value = &quot;req_post&quot;, method = RequestMethod.GET) public String postHi(String userName, String password) &#123; User user = new User(); user.setUserName(userName); user.setPassword(password); User res = adminService.postHi(user); return String.format(&quot;%s ,welcome! I am from port %s&quot;, userName, res.getPort()); &#125;&#125; 测试GET访问http://localhost:8765/hi?message=12345,将出现以下内容 1Hi，your message is : 12345 i am from port : 8762 POST访问http://localhost:8765/req_post?userName=mo&amp;password=123456,将出现以下内容 1mo ,welcome! I am from port 8762 如果配置多个cloud-admin-service服务，多次访问此接口，端口号应当随之变化","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"Feign","slug":"Feign","permalink":"https://xuzhengtong.com/tags/Feign/"}]},{"title":"Spring Cloud Netflix 创建服务消费者——Ribbon（四）","slug":"microservices/spring-cloud-netflix/ribbon","date":"2019-12-18T12:10:29.000Z","updated":"2019-12-18T12:10:29.000Z","comments":true,"path":"2019/12/18/microservices/spring-cloud-netflix/ribbon/","link":"","permalink":"https://xuzhengtong.com/2019/12/18/microservices/spring-cloud-netflix/ribbon/","excerpt":"概述在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于 http restful 的。Spring cloud 有两种服务调用方式，一种是 ribbon + restTemplate，另一种是 feign。","text":"概述在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于 http restful 的。Spring cloud 有两种服务调用方式，一种是 ribbon + restTemplate，另一种是 feign。 Ribbon+RestTemplateRibbon 是一个负载均衡客户端，可以很好的控制 http 和 tcp 的一些行为。 创建服务消费者 完整pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xzt&lt;/groupId&gt; &lt;artifactId&gt;cloud-ribbon-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-ribbon-service&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml1234567891011spring: application: name: cloud-ribbon-serviceserver: port: 8764eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ Configuration 配置注入 RestTemplate 的 Bean，并通过 @LoadBalanced 注解表明开启负载均衡功能 s 123456789101112131415package com.xzt.ribbon.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class RestTemplateConfiguration &#123; @LoadBalanced @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; Service1234567891011121314151617181920212223242526272829package com.xzt.ribbon.test.service;import com.xzt.ribbon.test.beans.User;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;@Servicepublic class AdminService &#123; private Logger logger = LoggerFactory.getLogger(AdminService.class); @Autowired private RestTemplate restTemplate; public String sayHi(String message) &#123; return restTemplate.getForObject(&quot;http://CLOUD-ADMIN-SERVICE/hi?message=&quot; + message, String.class); &#125; public String postHi(String userName, String password) &#123; User user = new User(); user.setUserName(userName); user.setPassword(password); User res = restTemplate.postForObject(&quot;http://CLOUD-ADMIN-SERVICE/req_post&quot;, user, User.class); return String.format(&quot;%s ,welcome! I am from port %s&quot;, userName, res.getPort()); &#125;&#125; Controller1234567891011121314151617181920212223package com.xzt.ribbon.test.controller;import com.xzt.ribbon.test.service.AdminService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; @Autowired private AdminService adminService; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(String message) &#123; return adminService.sayHi(message); &#125; @RequestMapping(value = &quot;req_post&quot;, method = RequestMethod.GET) public String postHi(String userName, String password) &#123; return adminService.postHi(userName, password); &#125;&#125; 在cloud-admin-service 增加以下接口123456@RequestMapping(value = &quot;req_post&quot;, method = RequestMethod.POST)public User postHi(@RequestBody User user)&#123; logger.info(&quot;userName:&#123;&#125;----password:&#123;&#125;&quot;,user.getUserName(),user.getPassword()); user.setPort(port); return user;&#125; 测试GET访问http://localhost:8764/hi?message=12345,将出现以下内容 1Hi，your message is : 12345 i am from port : 8762 POST访问http://localhost:8764/req_post?userName=mo&amp;password=123456,将出现以下内容 1mo ,welcome! I am from port 8762 如果配置多个cloud-admin-service服务，多次访问此接口，端口号应当随之变化","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://xuzhengtong.com/tags/Ribbon/"},{"name":"RestTemplate","slug":"RestTemplate","permalink":"https://xuzhengtong.com/tags/RestTemplate/"}]},{"title":"Spring Cloud Netflix 使用路由网关的服务过过滤功能（三）","slug":"microservices/spring-cloud-netflix/zuul-filter","date":"2019-12-16T09:40:27.000Z","updated":"2019-12-16T09:40:27.000Z","comments":true,"path":"2019/12/16/microservices/spring-cloud-netflix/zuul-filter/","link":"","permalink":"https://xuzhengtong.com/2019/12/16/microservices/spring-cloud-netflix/zuul-filter/","excerpt":"创建服务过滤器","text":"创建服务过滤器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.xzt.zuul;import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import com.netflix.zuul.exception.ZuulException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@Componentpublic class MyFilter extends ZuulFilter &#123; private Logger logger = LoggerFactory.getLogger(MyFilter.class); /** * 配置过滤类型，有四种不同生命周期的过滤器类型 * 1. pre：路由之前 * 2. routing：路由之时 * 3. post：路由之后 * 4. error：发送错误调用 * @return */ @Override public String filterType() &#123; return &quot;pre&quot;; &#125; /** * 配置过滤的顺序 * @return */ @Override public int filterOrder() &#123; return 0; &#125; /** * 配置是否需要过滤：true/需要，false/不需要 * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; /** * 过滤器的具体业务代码 * @return * @throws ZuulException */ @Override public Object run() throws ZuulException &#123; RequestContext context = RequestContext.getCurrentContext(); HttpServletRequest request = context.getRequest(); logger.info(&quot;&#123;&#125; &gt;&gt;&gt; &#123;&#125;&quot;, request.getMethod(), request.getRequestURL().toString()); String message = request.getParameter(&quot;message&quot;); if (message == null) &#123; logger.warn(&quot;Message is empty&quot;); context.setSendZuulResponse(false); context.setResponseStatusCode(401); try &#123; context.getResponse().getWriter().write(&quot;Message is empty&quot;); &#125; catch (IOException e) &#123; &#125; &#125; else &#123; logger.info(&quot;OK&quot;); &#125; return null; &#125;&#125; 测试 浏览器访问：http://localhost:8769/api/a/hi?message=HelloZuul网页显示 1Message is empty","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"zuul","slug":"zuul","permalink":"https://xuzhengtong.com/tags/zuul/"}]},{"title":"Spring Cloud Netflix 使用路由网关统一访问接口（二）","slug":"microservices/spring-cloud-netflix/zuul","date":"2019-12-09T13:48:56.000Z","updated":"2019-12-09T13:48:56.000Z","comments":true,"path":"2019/12/09/microservices/spring-cloud-netflix/zuul/","link":"","permalink":"https://xuzhengtong.com/2019/12/09/microservices/spring-cloud-netflix/zuul/","excerpt":"Zuul 简介Zuul 的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如 /api/user 转发到到 User 服务，/api/shop 转发到到 Shop 服务。Zuul 默认和 Ribbon 结合实现了负载均衡的功能。","text":"Zuul 简介Zuul 的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如 /api/user 转发到到 User 服务，/api/shop 转发到到 Shop 服务。Zuul 默认和 Ribbon 结合实现了负载均衡的功能。 创建路由网关 完整pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xzt&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-zuul&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-cloud-zuul&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml配置文件1234567891011121314151617spring: application: name: spring-cloud-zuulserver: port: 8769eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/zuul: routes: api-1: path: /admin/** serviceId: cloud-admin-service 路由说明： 以 /cloud-admin-client/ 开头的请求都转发给 cloud-admin-client 服务 Application启动类1234567891011121314151617package com.xzt.zuul;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@SpringBootApplication@EnableEurekaClient@EnableZuulProxypublic class SpringCloudZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudZuulApplication.class, args); &#125;&#125; 启动工程，打开浏览器访问：http://127.0.0.1:8769/cloud-admin-client/hi?message=HelloSpring浏览器显示: 1Hi，your message is : HelloSpring i am from port : 8762 配置网关路由失败时的回调12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.xzt.zuul;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.client.ClientHttpResponse;import org.springframework.stereotype.Component;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.Map;@Componentpublic class WebAdminFeignFallbackProvider implements FallbackProvider &#123; @Override public String getRoute() &#123; // ServiceId，如果需要所有调用都支持回退，则 return &quot;*&quot; 或 return null return null; &#125; @Override public ClientHttpResponse fallbackResponse(String route, Throwable cause) &#123; return new ClientHttpResponse() &#123; /** * 网关向 api 服务请求失败了，但是消费者客户端向网关发起的请求是成功的， * 不应该把 api 的 404,500 等问题抛给客户端 * 网关和 api 服务集群对于客户端来说是黑盒 * @return * @throws IOException */ @Override public HttpStatus getStatusCode() throws IOException &#123; return HttpStatus.OK; &#125; @Override public int getRawStatusCode() throws IOException &#123; return HttpStatus.OK.value(); &#125; @Override public String getStatusText() throws IOException &#123; return HttpStatus.OK.getReasonPhrase(); &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; ObjectMapper objectMapper = new ObjectMapper(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;status&quot;, 200); map.put(&quot;message&quot;, &quot;无法连接，请检查您的网络&quot;); return new ByteArrayInputStream(objectMapper.writeValueAsString(map).getBytes(&quot;UTF-8&quot;)); &#125; @Override public HttpHeaders getHeaders() &#123; HttpHeaders headers = new HttpHeaders(); // 和 getBody 中的内容编码一致 headers.setContentType(MediaType.APPLICATION_JSON_UTF8); return headers; &#125; &#125;; &#125;&#125; 如果访问http://127.0.0.1:8769/cloud-admin-client/hi?message=HelloSpring失败，则显示： 1&#123;&quot;message&quot;:&quot;无法连接，请检查您的网络&quot;,&quot;status&quot;:200&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"zuul","slug":"zuul","permalink":"https://xuzhengtong.com/tags/zuul/"}]},{"title":"Spring Cloud Netflix 初体验，创建Eureka注册中心和服务提供者（一）","slug":"microservices/spring-cloud-netflix/Eureka","date":"2019-12-09T12:29:39.000Z","updated":"2019-12-09T12:29:39.000Z","comments":true,"path":"2019/12/09/microservices/spring-cloud-netflix/Eureka/","link":"","permalink":"https://xuzhengtong.com/2019/12/09/microservices/spring-cloud-netflix/Eureka/","excerpt":"服务注册与发现Eureka以下将使用 Intellij Spring Initializr创建","text":"服务注册与发现Eureka以下将使用 Intellij Spring Initializr创建 完整pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xzt&lt;/groupId&gt; &lt;artifactId&gt;cloud-eureka-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-eureka-service&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml 配置文件123456789101112131415spring: application: name: cloud-eureka-serviceserver: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ Application 启动类添加@EnableEurekaServer注解 123456789101112131415package com.xzt.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class CloudEurekaServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudEurekaServiceApplication.class, args); &#125;&#125; 至此，即可启动 Eureka 注册中心，在浏览器输入 http://localhost:8761 即可看到Eureka server界面 创建服务提供者 完整pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xzt&lt;/groupId&gt; &lt;artifactId&gt;cloud-admin-client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-admin-client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml 配置文件1234567891011spring: application: name: cloud-admin-serviceserver: port: 8762eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ Application 启动类123456789101112131415package com.xzt.admin;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class CloudAdminClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudAdminClientApplication.class, args); &#125;&#125; Controller123456789101112131415161718package com.xzt.admin.test;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String port; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam(value = &quot;message&quot;) String message) &#123; return String.format(&quot;Hi，your message is : %s i am from port : %s&quot;, message, port); &#125;&#125; 启动工程，会看到如下界面中多了一个名为 CLOUD-ADMIN-CLIENT 的服务，打开 http://localhost:8762/hi?message=HelloSpring ，你会在浏览器上看到 : 1Hi，your message is :&quot;HelloSpring&quot; i am from port：8762 总结在进行接下来的内容之前，需要深度理解一下前面的内容。对此，我提出了下面的一些问题： 为什么要有Eureka？“发现” 是什么意思？ 注册中心是所有微服务实例及其位置的数据库。Netflix Eureka 是一个服务注册中心，它提供了一组用于管理服务实例注册和查询可用实例的 REST API。 关于服务发现，参阅4.服务发现 上面的例子中服务提供者已经提供了对外访问接口，假如有n个服务，难道客户端要通过n个不同的接口访问微服务吗？ API 网关是一个服务器，是系统的单入口点。它类似于面向对象设计模式中的门面（Facade）模式。API 网关封装了内部系统架构，并针对每个客户端提供一个定制 API。它还可用于认证、监控、负载均衡、缓存和静态响应处理。参阅 2.API网关 多个不同的服务之间如何通信？ 在单体应用中，组件可通过语言级方法或者函数相互调用。相比之下，基于微服务的应用是一个运行在多台机器上的分布式系统。通常，每个服务实例都是一个进程。 服务必须使用进程间通信（IPC）机制进行交互。 参阅 3.进程间通信","categories":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"Eureka","slug":"Eureka","permalink":"https://xuzhengtong.com/tags/Eureka/"}]},{"title":"Oracle自增主键","slug":"database/oracle/increasing-key","date":"2019-11-28T08:56:39.000Z","updated":"2019-11-28T08:56:39.000Z","comments":true,"path":"2019/11/28/database/oracle/increasing-key/","link":"","permalink":"https://xuzhengtong.com/2019/11/28/database/oracle/increasing-key/","excerpt":"设置Oracle自增主键","text":"设置Oracle自增主键 自增序列1234567create sequence seq_no minvalue 1 --最小值 nomaxvalue --最大值 start with 1 --起始值 increment by 1 --增长基数 nocycle --不循环，一直增加 nocache ; -- 不使用缓存 使用的时候使用seq_no.nextval，如： 1insert into student(student_id,first_name,last_name) values(seq_no.nextval,&#x27;&#x27;,&#x27;&#x27;); 查看 1select * from dba_sequences where sequence_owner=&#x27;用户名&#x27;; 删除 1DROP SEQUENCE seq_no --删除序列 还可以增加触发器，这样就可以不用指定主键的值而自动插入： 触发器名：tri_student_ins 表名：student 列名（主键）：student_id 12345create trigger tri_student_ins before insert on student for each row when (new.student_id is null) begin select seq_no.nextval into:new.student_id from dual; end; 查看 1select trigger_name from all_triggers where table_name=&#x27;XXX&#x27;; 删除 1DROP TRIGGER PERSON_trigger --删除触发器 函数使用自增主键的优点很明显——使用方便。但是查看就不是很方便了，对于有持久化要求的还是使用函数将主键值保存到数据库表中便于维护。 创建函数： 1234567891011121314151617181920212223CREATE OR REPLACE FUNCTION GETMAXNO(NOTYPE in varchar2)RETURN NUMBERAS MaxNo number(18); pragma autonomous_transaction;BEGIN select max_no into MaxNo FROM Sys_MaxNo where NO_TYPE=NOTYPE FOR UPDATE; MaxNo:=MaxNo+1; update Sys_MaxNo set max_no=MaxNo where NO_TYPE=NOTYPE; commit; RETURN MaxNo;exception when no_data_found then begin MaxNo:=1; insert into Sys_MaxNo(no_type,max_no) values(NOTYPE,MaxNo); commit; RETURN MaxNo; end; when others then rollback;END GETMAXNO; 这里的SYS_MAXNO有两个字段：MAX_NO : varchar2 NO_TYPE : number","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"数据库/Oracle","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://xuzhengtong.com/tags/Oracle/"}]},{"title":"wx小程序滑动验证组件","slug":"mini-program/wx-slider-verification","date":"2019-07-30T13:19:21.000Z","updated":"2019-07-30T13:19:21.000Z","comments":true,"path":"2019/07/30/mini-program/wx-slider-verification/","link":"","permalink":"https://xuzhengtong.com/2019/07/30/mini-program/wx-slider-verification/","excerpt":"事情起因由于客户需求的原因，需要做一个wx小程序的滑动验证的功能，然而","text":"事情起因由于客户需求的原因，需要做一个wx小程序的滑动验证的功能，然而在网上查阅许多资料后，发现这是一件很费劲的事情。相关的借鉴较少，即便参照某些教程，真机调试会有相当程度的卡顿问题，以及网络图片无法加载等等各种问题。谨以此来让后来者少走些弯路吧。 项目地址 开发过程以及一些问题大致的思路是：使用两张画布（canvas），一张画出扣除滑块的背景，一张用来画出滑块，其中第一张画布使用绝对布局，第二张画布使用相对（默认）布局，这样两张画布就能层叠到一起，并且滑块在背景之上，由于第二张画布默认布局，接下来添加控件就能在其之下继续添加。 使用方法概述此项目相当于开发了一个组件（官方文档搜索conponments），有相当详细的使用教程。在此不再赘述，对于此项目，只需在xml界面引入 1&lt;jigsaw bindmyevent=&quot;myEventListener&quot;&gt;&lt;/jigsaw 它有两个如下属性，你只需要在jigsaw标签内使用即可，默认为300x150尺寸，不建议去设置它的值，因为可能会涉及到一些css样式的修改。 1234properties: &#123; canvasWidth: Number, canvasHeight: Number &#125;, 事件名为：myevent，在页面js中配置监听事件后，只会在滑块成功时触发，且只设置了一个返回值result，为布尔类型。个人觉得已经足够了。添加更多返回值，请在jigsaw.js中找到以下位置： 123456if (limit &lt; 3) &#123; var myEventDetail = &#123; &quot;result&quot;: true &#125; // detail对象，提供给事件监听函数 that.triggerEvent(&#x27;myevent&#x27;, myEventDetail) &#125; 大致的使用方法就这些了，了解这些内容基本已能完全使用该组件了。如果你想深入的解读源码，以及了解该组件解决了什么问题，请继续阅读。 一些问题 卡顿问题 相信很多人会找到这篇文章都是遇到了真机调试的卡顿问题，而且有相当一部分人搜索完百度后会被误导成认为“canvas导致的卡顿”等等。刚开始的时候我也是这么认为的，直到我看见了下面的内容： 常见的 setData 操作错误1. 频繁的去 setData 在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果： Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层； 渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时； 2. 每次 setData 都传递大量新数据 由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程， 3. 后台态页面进行 setData 当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。 这是来自官方文档性能篇的一段话，详细看完之后，总结起来就是，在js监听的change之类的高频率刷新的事件，应当避免使用setData设置页面数据。对于这类动画的监听操作，我找到了一个替代品：wxs响应事件，在此页面中监听事件，你可以动态的获取该组件的相关参数（e）以及通过（instance）找到页面中的每个组件的实例，并且设置其class和style属性，就像这样： 123ins.selectComponent(&#x27;.block&#x27;).setStyle(&#123; left: &#x27;&#123;&#123;-x&#125;&#125;px&#x27;, &#125;) 需要注意的两点： 1.通过此方式设置style样式之后，原xml页面通过动态绑定（““像这样）的数据将失效 2.e中包含本例的instance对象 网络图片 在微信小程序中我还没发现一个能在真机上正常使用canvas加载的网络图片。由此上网上找了一个替代的方法，即：将图片缓存或下载到本地，再进行画布操作。 1234567wx.getImageInfo(&#123; src: &#x27;https://picsum.photos/1200/600/&#x27;,//这里直接就是随机的图片，不需要做随机函数 success: function(res) &#123; //console.log(res) that.setData(&#123; url: res.path, &#125;) 成功的状态 下方的slider使用wx小程序的movable-view（移动视图）做的，通过touchend事件来进行滑块验证成功与否的验证，然而搞笑的是，这个监听事件不提供x坐标（非PageX），至少我目前只在change事件发现过它。后来我放弃了，改用如下方式获取组件信息，在onLoad的时候执行一次记录slider的PageX，阿然后在touchend的监听事件中再执行一次，两者相减即为x的值（slider位移）,再用此值和随机生成的滑块的位置的x值相减并取绝对值，即为误差 123456789const query = this.createSelectorQuery() query.select(&#x27;#slider&#x27;).boundingClientRect() query.exec(function(res) &#123; //console.log(res) that.setData(&#123; left: res[0].left &#125;) //console.log(that.data.left) &#125;) 刷新的坑 前面已经提到过：wxs设置style样式后将导致原有数据绑定的样式失效，那么如果不做处理，刷新后，滑块的位置将达不到所期望的效果。解决方式很简单，通过事件的冒泡，重新设置style 123&lt;cover-view class=&#x27;ima_wrap&#x27; bindtouchend=&#x27;&#123;&#123;jigsaw.onEnd&#125;&#125;&#x27;&gt; &lt;cover-image src=&#x27;&#123;&#123;cover_image&#125;&#125;&#x27; bindtouchstart=&#x27;onTouchStart&#x27; bindtouchend=&#x27;onTouchEnd&#x27; hidden=&#x27;&#123;&#123;cover_hidden&#125;&#125;&#x27;&gt;&lt;/cover-image&gt;&lt;/cover-view&gt; 12345function onEnd(e,ins)&#123; ins.selectComponent(&#x27;.block&#x27;).setStyle(&#123; left: &#x27;&#123;&#123;-x&#125;&#125;px&#x27;, &#125;)&#125; 在你点击图片刷新的时候，会重置style的设置，重新改为动态绑定的形式。此事件的执行顺序为由内而外 此项目正确运行的截图：","categories":[{"name":"wx小程序开发","slug":"wx小程序开发","permalink":"https://xuzhengtong.com/categories/wx%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"适配器模式","slug":"design-pattern/adapter-pattern","date":"2019-07-18T13:00:23.000Z","updated":"2019-07-18T13:00:23.000Z","comments":true,"path":"2019/07/18/design-pattern/adapter-pattern/","link":"","permalink":"https://xuzhengtong.com/2019/07/18/design-pattern/adapter-pattern/","excerpt":"适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。","text":"适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 1234567891011121314151617181920212223242526272829303132333435363738//第一种public class Adapter implements MP3Player &#123; private WMAPlayer wmaPlayer; private Adapter() &#123; super(); &#125; public Adapter(WMAPlayer wmaPlayer)&#123; this.wmaPlayer = wmaPlayer; &#125; @Override public void work() &#123; wmaPlayer.work(); &#125;&#125;MP3Player mp3Player = new MP3PlayerImpl();WMAPlayer wmaPlayer = new WMAPlayerImpl();MP3Player adapter = new Adapter(wmaPlayer);mp3Player.work();adapter.work();//第二种（抽象、重写机制）public abstract class AnimalAdapter &#123; public void run() &#123; &#125; public void eat() &#123; &#125; public void swim() &#123; &#125;&#125;public class Dog extends AnimalAdapter &#123; @Override public void run() &#123; System.out.println(&quot;run&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuzhengtong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"代理模式和模板模式","slug":"design-pattern/proxy-and-template-pattern","date":"2019-07-18T13:00:09.000Z","updated":"2019-07-18T13:00:09.000Z","comments":true,"path":"2019/07/18/design-pattern/proxy-and-template-pattern/","link":"","permalink":"https://xuzhengtong.com/2019/07/18/design-pattern/proxy-and-template-pattern/","excerpt":"在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。","text":"在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 实例创建一个动作（action）接口，自定义其实现，并为这个实现添加代理。 123456789101112131415161718192021222324252627282930313233343536373839public interface Action &#123; void doAction();&#125;public class UserAction implements Action &#123; @Override public void doAction() &#123; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125;public class ProxyAction implements Action &#123; private UserAction userAction; public ProxyAction(UserAction userAction) &#123; this.userAction = userAction; &#125; @Override public void doAction() &#123; long startTime = System.currentTimeMillis(); userAction.doAction();//真正执行的业务 long endTime = System.currentTimeMillis(); System.out.println(&quot;执行时间&quot; + (endTime-startTime)); &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; Action action1 = new UserAction(); Action action2 = new ProxyAction((UserAction) action1); action2.doAction(); &#125;&#125; 模板模式意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 主要解决：一些方法通用，却在每一个子类都重新写了这一方法。 何时使用：有一些通用的方法。 如何解决：将这些通用算法抽象出来。 关键代码：在抽象类实现，其他步骤在子类实现。 12345678910111213141516171819202122232425abstract class BaseManger &#123; /** * 验证权限 * @param name * @param method */ public void action(String name,String method)&#123; if (&quot;admin&quot;.equals(name))&#123; execute(method); &#125;else &#123; System.out.println(&quot;无权限&quot;); &#125; &#125; public abstract void execute(String method);&#125;public class UserManger extends BaseManger&#123; public void execute(String method)&#123; if (&quot;add&quot;.equals(method)) &#123; System.out.println(&quot;添加&quot;); &#125;else if(&quot;del&quot;.equals(method))&#123; System.out.println(&quot;删除&quot;); &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuzhengtong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"工厂模式","slug":"design-pattern/factory-pattern ","date":"2019-07-15T12:58:23.000Z","updated":"2019-07-15T12:58:23.000Z","comments":true,"path":"2019/07/15/design-pattern/factory-pattern /","link":"","permalink":"https://xuzhengtong.com/2019/07/15/design-pattern/factory-pattern%20/","excerpt":"工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。","text":"工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 实例定义一个形状（Sharp）父类，其子类有圆（Circle），正方形（Square），长方形（Rectangle）； 通过工厂模式获取其子类实例。 简单工厂模式1.静态工厂123456789101112131415161718/** * 静态工厂 * @author XuZhengtong * @date 2019/7/15 21:27 */public class StaticFactory &#123; public static ShapeMe getShape(String name)&#123; if (name==null)return null; if (&quot;circle&quot;.equals(name))&#123; return new Circle(); &#125;else if (&quot;square&quot;.equals(name))&#123; return new Square(); &#125;else if (&quot;rectangle&quot;.equals(name))&#123; return new Rectangle(); &#125; return null; &#125;&#125; 可通过类名.get方法获取相应对象。 2.实例工厂去掉上例static修饰，然后通过实例化工厂类并调用get方法获取相应对象。 工厂方法模式12345678910111213141516/** * 工厂方法模式 * @author XuZhengtong * @date 2019/7/15 21:48 */public interface Factory &#123; ShapeMe getSharp();&#125;public class CircleFactory implements Factory &#123; @Override public ShapeMe getSharp() &#123; return new Circle(); &#125;&#125;...//其他形状略过 获取实例方式： 12Factory factory = new CircleFactory();ShapeMe s3 = factory.getSharp(); 抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。 在上例中再加入一个实体类Color，对应子类Blue，Yellow。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 抽象工厂方法 * @author XuZhengtong * @date 2019/7/15 22:06 */public abstract class AbstractFactory &#123; public abstract ShapeMe getSharp(String name); public abstract ColorMe getColor(String name);&#125;public class SharpFactory extends AbstractFactory &#123; @Override public ShapeMe getSharp(String name) &#123; if (name==null)return null; if (&quot;circle&quot;.equals(name))&#123; return new Circle(); &#125;else if (&quot;square&quot;.equals(name))&#123; return new Square(); &#125;else if (&quot;rectangle&quot;.equals(name))&#123; return new Rectangle(); &#125; return null; &#125; @Override public ColorMe getColor(String name) &#123; return null; &#125;&#125;public class ColorFactory extends AbstractFactory &#123; @Override public ShapeMe getSharp(String name) &#123; return null; &#125; @Override public ColorMe getColor(String name) &#123; if (name==null)return null; if (&quot;blue&quot;.equals(name))&#123; return new Blue(); &#125;else if (&quot;yellow&quot;.equals(name))&#123; return new Yellow(); &#125; return null; &#125;&#125; 可以看出，这种方式对于创建一个新的工厂有优势 然后你还需要创建一个工厂创造器&#x2F;生成器类，通过传递形状或颜色信息来获取工厂 1234567891011public class FactoryProducer &#123; public static AbstractFactory getFactory(String name)&#123; if (name==null)return null; if (&quot;sharp&quot;.equals(name))&#123; return new SharpFactory(); &#125;else if (&quot;color&quot;.equals(name))&#123; return new ColorFactory(); &#125; return null; &#125;&#125; 获取方式如下 12AbstractFactory sharpFactory = FactoryProducer.getFactory(&quot;sharp&quot;);ShapeMe s4 = sharpFactory.getSharp(&quot;circle&quot;); 总结开发过程中常用的应该是简单工厂模式和抽象工厂模式，当需要频繁为实体类添加工厂时，抽象工厂模式占优。 参靠：工厂模式|菜鸟教程","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuzhengtong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"关联域名","slug":"blog-create-use/set-domain","date":"2019-07-10T13:56:35.000Z","updated":"2019-07-10T13:56:35.000Z","comments":true,"path":"2019/07/10/blog-create-use/set-domain/","link":"","permalink":"https://xuzhengtong.com/2019/07/10/blog-create-use/set-domain/","excerpt":"前言是时候选个个性化的网站地址了。","text":"前言是时候选个个性化的网站地址了。 准备一个域名，现在有很多网站都提供免费的域名，我用的是腾讯云购买的.com域名。 配置域名解析域名解析都是要在你购买的网站的控制台操作的。 方式一首先获取你的主页ip，使用的你的电脑打开命令行（cmd），执行命令 1ping yourname.github.io 然后将得到的地址按如图方式处理： 方式二直接添加如图解析：（强迫症建议方式，方式一的ip是不断在一小段范围内变化的，但是可以正常访问，但是对于强迫症患者，这么一小点瑕疵足以将其弃用了。。。。） 配置CNAME 文件（重要）如果不进行以下配置，是不能够正常访问的。配置方式也相当简单，在F:\\blog\\source中新建CNAME记事本文件，在其中写入你的域名，保存后去掉.txt后缀。 github绑定域名进入你的github中的blog项目，如图： 然后将你的blog再次部署到github","categories":[{"name":"个人博客创建及使用","slug":"个人博客创建及使用","permalink":"https://xuzhengtong.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"}],"tags":[]},{"title":"撰写博客","slug":"blog-create-use/write","date":"2019-07-09T12:12:44.000Z","updated":"2019-07-09T12:12:44.000Z","comments":true,"path":"2019/07/09/blog-create-use/write/","link":"","permalink":"https://xuzhengtong.com/2019/07/09/blog-create-use/write/","excerpt":"前言完成hexo静态博客的创建后，就可以开始尝试写一篇文章了。","text":"前言完成hexo静态博客的创建后，就可以开始尝试写一篇文章了。在此之前你需要了解MarkDown Markdown Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式。如果你学过前端知识或者对word文档特别熟练，那么你会发现MarkDown会相当简单。即便是不从事编程行业的人，也可以在几个小时内入手。 在此不再对MarkDown语法进行介绍。熟练之后你会发现使用MarkDown甚至是一种享受，So,just enjoy it. 写文章在此介绍我撰写博客的习惯，所以只会讲述频繁用到的一些东西。想要全面的介绍可以前往Hexo文档。 创建文章在站点文件夹下打开Git Bash，输入以下命令创建文章，其中title为文章标题 1hexo new &quot;title&quot; 执行完命令后，会在source&#x2F;_post文件夹下生成一个名为title.md的MarkDown文件，在此文件中编写你的文章。 引用图片 设置根目录_config.yml中post_asset_folder: true。然后你如果再次创建文章会生成一个同名文件夹用于存放图片资源。 hexo3以上版本不需要安装image插件（重要），因为现在网上很多教程都让你下插件。 引用图片方式参考Hexo文档。1&#123;% asset_img example.jpg This is an example image %&#125; 关于此引用方式，asset_img为类型，不要更改；example.jpg为文件名（非路径）；This is an example image为自定义的说明 启用标签页和分类页 首先，你需要在你使用的主题目录下的_config.yml配置文件中取消menu下tag和categories的注释。 然后在blog根目录打开Git Bash，执行以下命令12hexo new page tags//标签hexo new page categories//分类 执行完毕后会在source文件夹下生成tag和 categories文件夹，修改这两个文件夹下index.md为以下内容123456789title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;---//注意：本行上下是两个文件的内容（提一下，防止不细看的人。）title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;--- 模板设置当我们使用命令hexo new “title”创建文章时，Hexo会根据模板对新文章进行初始化。模板：&#x2F;scaffolds&#x2F;post.md一个简单的例子： 1234title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: 首页文章简单显示部分主题首页会显示文章的全部内容，显得十分冗余，所以有必要只显示一部分内容。在适当位置添加 1&lt;!--more--&gt; 只会显示标志之前的内容。 部署发布123hexo cleanhexo ghexo d","categories":[{"name":"个人博客创建及使用","slug":"个人博客创建及使用","permalink":"https://xuzhengtong.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"}],"tags":[]},{"title":"使用hexo和GitHub创建你的博客","slug":"blog-create-use/blog-create","date":"2019-07-08T12:54:37.000Z","updated":"2019-07-08T12:54:37.000Z","comments":true,"path":"2019/07/08/blog-create-use/blog-create/","link":"","permalink":"https://xuzhengtong.com/2019/07/08/blog-create-use/blog-create/","excerpt":"前言什么是Hexo：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。","text":"前言什么是Hexo：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Github pages：GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。想建立个人博客是用的第一种，形如cnfeat.github.io这样的可访问的站，每个用户名下面只能建立一个。 步骤开启Github page注册github账号后按如图步骤操作，其中yourname为你的github用户名。 Hexo搭建博客网站安装git 点击下载，然后默认选项安装即可。 安装完成后，任意空位置鼠标右键，出现“Git Bash”，点击出现一个类似命令行窗口，就说明安装成功。 在此命令窗口执行以下命令，建议用户名密码和你Github用户名一致。12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 安装node.js 点击下载，默认安装即可。 Hexo安装打开 Git Bash，执行 1npm install -g hexo-cli 本地部署Hexo 新建一个文件夹，用于存放博客项目，如：F:\\blog 在此文件夹右键打开Git Bash，依次执行：12hexo initnpm install 出现如下目录结构即为安装成功：12345678.├── _config.yml // 网站的配置信息，你可以在此配置大部分的参数。├── package.json├── scaffolds // 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件。├── source // 存放用户资源的地方 | ├── _drafts | └── _posts└── themes // 存放网站的主题。Hexo会根据主题来生成静态页面。 输入hexo s启动博客，在本地浏览器输入http://localhost:4000/即可访问。 更换hexo主题 以next主题为例，在blog文件夹下打开Git Bash，执行如下：1git clone https://github.com/theme-next/hexo-theme-next.git themes/next 打开D:\\blog下的_config.yml文件，找到theme字段，将其修改为next 通过hexo s再次启动blog，查看效果。 next详细使用教程可查看官方文档，点击前往。 托管到githubSSH配置SHH 检查是否已经有SSH Key，打开Git Bash，输入1cd ~/.ssh 如果没有.ssh这个目录，则生成一个新的SSH，输入1ssh-keygen -t rsa -C &quot;your e-mail&quot; 此处email和github注册时的email保持一致，不要纠结。另外，接下来会让你输入口令，不需要配置，一路enter。 添加 SSH Key 到 GitHub 任意位置打开Git Bash，然后输入1cd ~/.ssh 进入到.shh文件夹中再输入ls，查看文件列表 查看公钥1cat id_rsa.pub 将检索到的内容全部复制，然后配置到github。按图操作(图中2,3顺序颠倒) 在最后打开的页面，将复制的内容粘贴到key中，然后保存。 测试SSH是否配置成功 打开Git Bash，然后输入1ssh -T git@github.com 如配置了密码则要输入密码,输完按回车,如果显示以下内容，则说明Github中的ssh配置成功。1Hi username! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 将博客网站上传到GitHub 打开F:\\blog文件夹中的_config.yml文件，找到如下位置，填写123456# Deployment## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git,master 注： (1) 其中yourname替换成你的Github账户名;(2)注意在yml文件中，:后面都是要带空格的。 在blog文件夹中空白处右击打开Git Bash依次执行12hexo g #生成静态网页hexo d #开始部署 此时，可以通过访问http://yourname.github.io 访问你的博客了。 注：当你修改各类配置文件时，你可能需要重启Git Bash来适应你的更改。","categories":[{"name":"个人博客创建及使用","slug":"个人博客创建及使用","permalink":"https://xuzhengtong.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"}],"tags":[]}],"categories":[{"name":"jellyfin","slug":"jellyfin","permalink":"https://xuzhengtong.com/categories/jellyfin/"},{"name":"Synology","slug":"Synology","permalink":"https://xuzhengtong.com/categories/Synology/"},{"name":"hardware","slug":"hardware","permalink":"https://xuzhengtong.com/categories/hardware/"},{"name":"ja-netfilter","slug":"ja-netfilter","permalink":"https://xuzhengtong.com/categories/ja-netfilter/"},{"name":"加密算法","slug":"加密算法","permalink":"https://xuzhengtong.com/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"name":"RSA","slug":"加密算法/RSA","permalink":"https://xuzhengtong.com/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/RSA/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Trie","slug":"数据结构与算法/Trie","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Trie/"},{"name":"动态规划","slug":"数据结构与算法/动态规划","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"v2ray","slug":"v2ray","permalink":"https://xuzhengtong.com/categories/v2ray/"},{"name":"个人博客创建及使用","slug":"个人博客创建及使用","permalink":"https://xuzhengtong.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"微服务/Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud-Netflix/"},{"name":"docker","slug":"docker","permalink":"https://xuzhengtong.com/categories/docker/"},{"name":"网络配置","slug":"docker/网络配置","permalink":"https://xuzhengtong.com/categories/docker/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://xuzhengtong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据库","slug":"数据库","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"数据库/Oracle","permalink":"https://xuzhengtong.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/"},{"name":"wx小程序开发","slug":"wx小程序开发","permalink":"https://xuzhengtong.com/categories/wx%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"设计模式","slug":"设计模式","permalink":"https://xuzhengtong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"jellyfin","slug":"jellyfin","permalink":"https://xuzhengtong.com/tags/jellyfin/"},{"name":"tinymediamanager","slug":"tinymediamanager","permalink":"https://xuzhengtong.com/tags/tinymediamanager/"},{"name":"Synology","slug":"Synology","permalink":"https://xuzhengtong.com/tags/Synology/"},{"name":"人脸识别","slug":"人脸识别","permalink":"https://xuzhengtong.com/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"},{"name":"readmi ax6s","slug":"readmi-ax6s","permalink":"https://xuzhengtong.com/tags/readmi-ax6s/"},{"name":"m401a","slug":"m401a","permalink":"https://xuzhengtong.com/tags/m401a/"},{"name":"openwrt","slug":"openwrt","permalink":"https://xuzhengtong.com/tags/openwrt/"},{"name":"armbian","slug":"armbian","permalink":"https://xuzhengtong.com/tags/armbian/"},{"name":"ja-netfilter","slug":"ja-netfilter","permalink":"https://xuzhengtong.com/tags/ja-netfilter/"},{"name":"RSA","slug":"RSA","permalink":"https://xuzhengtong.com/tags/RSA/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xuzhengtong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"v2ray","slug":"v2ray","permalink":"https://xuzhengtong.com/tags/v2ray/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://xuzhengtong.com/tags/Jenkins/"},{"name":"docker","slug":"docker","permalink":"https://xuzhengtong.com/tags/docker/"},{"name":"微服务","slug":"微服务","permalink":"https://xuzhengtong.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud Netflix","slug":"Spring-Cloud-Netflix","permalink":"https://xuzhengtong.com/tags/Spring-Cloud-Netflix/"},{"name":"网络层","slug":"网络层","permalink":"https://xuzhengtong.com/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"Spring boot admin","slug":"Spring-boot-admin","permalink":"https://xuzhengtong.com/tags/Spring-boot-admin/"},{"name":"ZipKin","slug":"ZipKin","permalink":"https://xuzhengtong.com/tags/ZipKin/"},{"name":"熔断","slug":"熔断","permalink":"https://xuzhengtong.com/tags/%E7%86%94%E6%96%AD/"},{"name":"Feign","slug":"Feign","permalink":"https://xuzhengtong.com/tags/Feign/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://xuzhengtong.com/tags/Ribbon/"},{"name":"RestTemplate","slug":"RestTemplate","permalink":"https://xuzhengtong.com/tags/RestTemplate/"},{"name":"zuul","slug":"zuul","permalink":"https://xuzhengtong.com/tags/zuul/"},{"name":"Eureka","slug":"Eureka","permalink":"https://xuzhengtong.com/tags/Eureka/"},{"name":"Oracle","slug":"Oracle","permalink":"https://xuzhengtong.com/tags/Oracle/"}]}